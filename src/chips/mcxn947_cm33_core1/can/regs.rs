#[doc = "CAN Bit Timing"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cbt(pub u32);
impl Cbt {
    #[doc = "Extended Phase Segment 2"]
    #[must_use]
    #[inline(always)]
    pub const fn epseg2(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x1f;
        val as u8
    }
    #[doc = "Extended Phase Segment 2"]
    #[inline(always)]
    pub const fn set_epseg2(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
    }
    #[doc = "Extended Phase Segment 1"]
    #[must_use]
    #[inline(always)]
    pub const fn epseg1(&self) -> u8 {
        let val = (self.0 >> 5usize) & 0x1f;
        val as u8
    }
    #[doc = "Extended Phase Segment 1"]
    #[inline(always)]
    pub const fn set_epseg1(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 5usize)) | (((val as u32) & 0x1f) << 5usize);
    }
    #[doc = "Extended Propagation Segment"]
    #[must_use]
    #[inline(always)]
    pub const fn epropseg(&self) -> u8 {
        let val = (self.0 >> 10usize) & 0x3f;
        val as u8
    }
    #[doc = "Extended Propagation Segment"]
    #[inline(always)]
    pub const fn set_epropseg(&mut self, val: u8) {
        self.0 = (self.0 & !(0x3f << 10usize)) | (((val as u32) & 0x3f) << 10usize);
    }
    #[doc = "Extended Resync Jump Width"]
    #[must_use]
    #[inline(always)]
    pub const fn erjw(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x1f;
        val as u8
    }
    #[doc = "Extended Resync Jump Width"]
    #[inline(always)]
    pub const fn set_erjw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
    }
    #[doc = "Extended Prescaler Division Factor"]
    #[must_use]
    #[inline(always)]
    pub const fn epresdiv(&self) -> u16 {
        let val = (self.0 >> 21usize) & 0x03ff;
        val as u16
    }
    #[doc = "Extended Prescaler Division Factor"]
    #[inline(always)]
    pub const fn set_epresdiv(&mut self, val: u16) {
        self.0 = (self.0 & !(0x03ff << 21usize)) | (((val as u32) & 0x03ff) << 21usize);
    }
    #[doc = "Bit Timing Format Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn btf(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Timing Format Enable"]
    #[inline(always)]
    pub const fn set_btf(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cbt {
    #[inline(always)]
    fn default() -> Cbt {
        Cbt(0)
    }
}
impl core::fmt::Debug for Cbt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbt")
            .field("epseg2", &self.epseg2())
            .field("epseg1", &self.epseg1())
            .field("epropseg", &self.epropseg())
            .field("erjw", &self.erjw())
            .field("epresdiv", &self.epresdiv())
            .field("btf", &self.btf())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cbt {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cbt {{ epseg2: {=u8:?}, epseg1: {=u8:?}, epropseg: {=u8:?}, erjw: {=u8:?}, epresdiv: {=u16:?}, btf: {=bool:?} }}",
            self.epseg2(),
            self.epseg1(),
            self.epropseg(),
            self.erjw(),
            self.epresdiv(),
            self.btf()
        )
    }
}
#[doc = "Cyclic Redundancy Check"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Crcr(pub u32);
impl Crcr {
    #[doc = "Transmitted CRC value"]
    #[must_use]
    #[inline(always)]
    pub const fn txcrc(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x7fff;
        val as u16
    }
    #[doc = "Transmitted CRC value"]
    #[inline(always)]
    pub const fn set_txcrc(&mut self, val: u16) {
        self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
    }
    #[doc = "CRC Message Buffer"]
    #[must_use]
    #[inline(always)]
    pub const fn mbcrc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x7f;
        val as u8
    }
    #[doc = "CRC Message Buffer"]
    #[inline(always)]
    pub const fn set_mbcrc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
    }
}
impl Default for Crcr {
    #[inline(always)]
    fn default() -> Crcr {
        Crcr(0)
    }
}
impl core::fmt::Debug for Crcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crcr")
            .field("txcrc", &self.txcrc())
            .field("mbcrc", &self.mbcrc())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Crcr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Crcr {{ txcrc: {=u16:?}, mbcrc: {=u8:?} }}",
            self.txcrc(),
            self.mbcrc()
        )
    }
}
#[doc = "Message Buffer 0 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs0(pub u32);
impl Cs0 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs0 {
    #[inline(always)]
    fn default() -> Cs0 {
        Cs0(0)
    }
}
impl core::fmt::Debug for Cs0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs0")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs0 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 1 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs1(pub u32);
impl Cs1 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs1 {
    #[inline(always)]
    fn default() -> Cs1 {
        Cs1(0)
    }
}
impl core::fmt::Debug for Cs1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs1")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs1 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 10 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs10(pub u32);
impl Cs10 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs10 {
    #[inline(always)]
    fn default() -> Cs10 {
        Cs10(0)
    }
}
impl core::fmt::Debug for Cs10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs10")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs10 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 11 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs11(pub u32);
impl Cs11 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs11 {
    #[inline(always)]
    fn default() -> Cs11 {
        Cs11(0)
    }
}
impl core::fmt::Debug for Cs11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs11")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs11 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 12 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs12(pub u32);
impl Cs12 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs12 {
    #[inline(always)]
    fn default() -> Cs12 {
        Cs12(0)
    }
}
impl core::fmt::Debug for Cs12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs12")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs12 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 13 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs13(pub u32);
impl Cs13 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs13 {
    #[inline(always)]
    fn default() -> Cs13 {
        Cs13(0)
    }
}
impl core::fmt::Debug for Cs13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs13")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs13 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 14 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs14(pub u32);
impl Cs14 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs14 {
    #[inline(always)]
    fn default() -> Cs14 {
        Cs14(0)
    }
}
impl core::fmt::Debug for Cs14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs14")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs14 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 15 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs15(pub u32);
impl Cs15 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs15 {
    #[inline(always)]
    fn default() -> Cs15 {
        Cs15(0)
    }
}
impl core::fmt::Debug for Cs15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs15")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs15 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 16 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs16(pub u32);
impl Cs16 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs16 {
    #[inline(always)]
    fn default() -> Cs16 {
        Cs16(0)
    }
}
impl core::fmt::Debug for Cs16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs16")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs16 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs16 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 17 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs17(pub u32);
impl Cs17 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs17 {
    #[inline(always)]
    fn default() -> Cs17 {
        Cs17(0)
    }
}
impl core::fmt::Debug for Cs17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs17")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs17 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs17 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 18 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs18(pub u32);
impl Cs18 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs18 {
    #[inline(always)]
    fn default() -> Cs18 {
        Cs18(0)
    }
}
impl core::fmt::Debug for Cs18 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs18")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs18 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs18 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 19 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs19(pub u32);
impl Cs19 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs19 {
    #[inline(always)]
    fn default() -> Cs19 {
        Cs19(0)
    }
}
impl core::fmt::Debug for Cs19 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs19")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs19 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs19 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 2 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs2(pub u32);
impl Cs2 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs2 {
    #[inline(always)]
    fn default() -> Cs2 {
        Cs2(0)
    }
}
impl core::fmt::Debug for Cs2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs2")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs2 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 20 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs20(pub u32);
impl Cs20 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs20 {
    #[inline(always)]
    fn default() -> Cs20 {
        Cs20(0)
    }
}
impl core::fmt::Debug for Cs20 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs20")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs20 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs20 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 21 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs21(pub u32);
impl Cs21 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs21 {
    #[inline(always)]
    fn default() -> Cs21 {
        Cs21(0)
    }
}
impl core::fmt::Debug for Cs21 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs21")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs21 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs21 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 22 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs22(pub u32);
impl Cs22 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs22 {
    #[inline(always)]
    fn default() -> Cs22 {
        Cs22(0)
    }
}
impl core::fmt::Debug for Cs22 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs22")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs22 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs22 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 23 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs23(pub u32);
impl Cs23 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs23 {
    #[inline(always)]
    fn default() -> Cs23 {
        Cs23(0)
    }
}
impl core::fmt::Debug for Cs23 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs23")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs23 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs23 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 24 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs24(pub u32);
impl Cs24 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs24 {
    #[inline(always)]
    fn default() -> Cs24 {
        Cs24(0)
    }
}
impl core::fmt::Debug for Cs24 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs24")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs24 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs24 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 25 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs25(pub u32);
impl Cs25 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs25 {
    #[inline(always)]
    fn default() -> Cs25 {
        Cs25(0)
    }
}
impl core::fmt::Debug for Cs25 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs25")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs25 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs25 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 26 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs26(pub u32);
impl Cs26 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs26 {
    #[inline(always)]
    fn default() -> Cs26 {
        Cs26(0)
    }
}
impl core::fmt::Debug for Cs26 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs26")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs26 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs26 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 27 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs27(pub u32);
impl Cs27 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs27 {
    #[inline(always)]
    fn default() -> Cs27 {
        Cs27(0)
    }
}
impl core::fmt::Debug for Cs27 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs27")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs27 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs27 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 28 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs28(pub u32);
impl Cs28 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs28 {
    #[inline(always)]
    fn default() -> Cs28 {
        Cs28(0)
    }
}
impl core::fmt::Debug for Cs28 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs28")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs28 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs28 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 29 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs29(pub u32);
impl Cs29 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs29 {
    #[inline(always)]
    fn default() -> Cs29 {
        Cs29(0)
    }
}
impl core::fmt::Debug for Cs29 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs29")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs29 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs29 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 3 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs3(pub u32);
impl Cs3 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs3 {
    #[inline(always)]
    fn default() -> Cs3 {
        Cs3(0)
    }
}
impl core::fmt::Debug for Cs3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs3")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs3 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 30 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs30(pub u32);
impl Cs30 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs30 {
    #[inline(always)]
    fn default() -> Cs30 {
        Cs30(0)
    }
}
impl core::fmt::Debug for Cs30 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs30")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs30 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs30 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 31 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs31(pub u32);
impl Cs31 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs31 {
    #[inline(always)]
    fn default() -> Cs31 {
        Cs31(0)
    }
}
impl core::fmt::Debug for Cs31 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs31")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs31 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs31 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 4 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs4(pub u32);
impl Cs4 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs4 {
    #[inline(always)]
    fn default() -> Cs4 {
        Cs4(0)
    }
}
impl core::fmt::Debug for Cs4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs4")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs4 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 5 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs5(pub u32);
impl Cs5 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs5 {
    #[inline(always)]
    fn default() -> Cs5 {
        Cs5(0)
    }
}
impl core::fmt::Debug for Cs5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs5")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs5 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 6 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs6(pub u32);
impl Cs6 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs6 {
    #[inline(always)]
    fn default() -> Cs6 {
        Cs6(0)
    }
}
impl core::fmt::Debug for Cs6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs6")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs6 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 7 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs7(pub u32);
impl Cs7 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs7 {
    #[inline(always)]
    fn default() -> Cs7 {
        Cs7(0)
    }
}
impl core::fmt::Debug for Cs7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs7")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs7 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 8 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs8(pub u32);
impl Cs8 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs8 {
    #[inline(always)]
    fn default() -> Cs8 {
        Cs8(0)
    }
}
impl core::fmt::Debug for Cs8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs8")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs8 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 9 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cs9(pub u32);
impl Cs9 {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Cs9 {
    #[inline(always)]
    fn default() -> Cs9 {
        Cs9(0)
    }
}
impl core::fmt::Debug for Cs9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs9")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Cs9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Cs9 {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Control 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Ctrl1(pub u32);
impl Ctrl1 {
    #[doc = "Propagation Segment"]
    #[must_use]
    #[inline(always)]
    pub const fn propseg(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x07;
        val as u8
    }
    #[doc = "Propagation Segment"]
    #[inline(always)]
    pub const fn set_propseg(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
    }
    #[doc = "Listen-Only Mode"]
    #[must_use]
    #[inline(always)]
    pub const fn lom(&self) -> super::vals::Lom {
        let val = (self.0 >> 3usize) & 0x01;
        super::vals::Lom::from_bits(val as u8)
    }
    #[doc = "Listen-Only Mode"]
    #[inline(always)]
    pub const fn set_lom(&mut self, val: super::vals::Lom) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
    }
    #[doc = "Lowest Buffer Transmitted First"]
    #[must_use]
    #[inline(always)]
    pub const fn lbuf(&self) -> super::vals::Lbuf {
        let val = (self.0 >> 4usize) & 0x01;
        super::vals::Lbuf::from_bits(val as u8)
    }
    #[doc = "Lowest Buffer Transmitted First"]
    #[inline(always)]
    pub const fn set_lbuf(&mut self, val: super::vals::Lbuf) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
    }
    #[doc = "Timer Sync"]
    #[must_use]
    #[inline(always)]
    pub const fn tsyn(&self) -> super::vals::Tsyn {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Tsyn::from_bits(val as u8)
    }
    #[doc = "Timer Sync"]
    #[inline(always)]
    pub const fn set_tsyn(&mut self, val: super::vals::Tsyn) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Bus Off Recovery"]
    #[must_use]
    #[inline(always)]
    pub const fn boffrec(&self) -> super::vals::Boffrec {
        let val = (self.0 >> 6usize) & 0x01;
        super::vals::Boffrec::from_bits(val as u8)
    }
    #[doc = "Bus Off Recovery"]
    #[inline(always)]
    pub const fn set_boffrec(&mut self, val: super::vals::Boffrec) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
    }
    #[doc = "CAN Bit Sampling"]
    #[must_use]
    #[inline(always)]
    pub const fn smp(&self) -> super::vals::Smp {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Smp::from_bits(val as u8)
    }
    #[doc = "CAN Bit Sampling"]
    #[inline(always)]
    pub const fn set_smp(&mut self, val: super::vals::Smp) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "RX Warning Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn rwrnmsk(&self) -> super::vals::Rwrnmsk {
        let val = (self.0 >> 10usize) & 0x01;
        super::vals::Rwrnmsk::from_bits(val as u8)
    }
    #[doc = "RX Warning Interrupt Mask"]
    #[inline(always)]
    pub const fn set_rwrnmsk(&mut self, val: super::vals::Rwrnmsk) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
    }
    #[doc = "TX Warning Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn twrnmsk(&self) -> super::vals::Twrnmsk {
        let val = (self.0 >> 11usize) & 0x01;
        super::vals::Twrnmsk::from_bits(val as u8)
    }
    #[doc = "TX Warning Interrupt Mask"]
    #[inline(always)]
    pub const fn set_twrnmsk(&mut self, val: super::vals::Twrnmsk) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
    }
    #[doc = "Loopback Mode"]
    #[must_use]
    #[inline(always)]
    pub const fn lpb(&self) -> super::vals::Lpb {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::Lpb::from_bits(val as u8)
    }
    #[doc = "Loopback Mode"]
    #[inline(always)]
    pub const fn set_lpb(&mut self, val: super::vals::Lpb) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Error Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn errmsk(&self) -> super::vals::Errmsk {
        let val = (self.0 >> 14usize) & 0x01;
        super::vals::Errmsk::from_bits(val as u8)
    }
    #[doc = "Error Interrupt Mask"]
    #[inline(always)]
    pub const fn set_errmsk(&mut self, val: super::vals::Errmsk) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
    }
    #[doc = "Bus Off Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn boffmsk(&self) -> super::vals::Boffmsk {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::Boffmsk::from_bits(val as u8)
    }
    #[doc = "Bus Off Interrupt Mask"]
    #[inline(always)]
    pub const fn set_boffmsk(&mut self, val: super::vals::Boffmsk) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "Phase Segment 2"]
    #[must_use]
    #[inline(always)]
    pub const fn pseg2(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x07;
        val as u8
    }
    #[doc = "Phase Segment 2"]
    #[inline(always)]
    pub const fn set_pseg2(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
    }
    #[doc = "Phase Segment 1"]
    #[must_use]
    #[inline(always)]
    pub const fn pseg1(&self) -> u8 {
        let val = (self.0 >> 19usize) & 0x07;
        val as u8
    }
    #[doc = "Phase Segment 1"]
    #[inline(always)]
    pub const fn set_pseg1(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 19usize)) | (((val as u32) & 0x07) << 19usize);
    }
    #[doc = "Resync Jump Width"]
    #[must_use]
    #[inline(always)]
    pub const fn rjw(&self) -> u8 {
        let val = (self.0 >> 22usize) & 0x03;
        val as u8
    }
    #[doc = "Resync Jump Width"]
    #[inline(always)]
    pub const fn set_rjw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
    }
    #[doc = "Prescaler Division Factor"]
    #[must_use]
    #[inline(always)]
    pub const fn presdiv(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Prescaler Division Factor"]
    #[inline(always)]
    pub const fn set_presdiv(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Ctrl1 {
    #[inline(always)]
    fn default() -> Ctrl1 {
        Ctrl1(0)
    }
}
impl core::fmt::Debug for Ctrl1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ctrl1")
            .field("propseg", &self.propseg())
            .field("lom", &self.lom())
            .field("lbuf", &self.lbuf())
            .field("tsyn", &self.tsyn())
            .field("boffrec", &self.boffrec())
            .field("smp", &self.smp())
            .field("rwrnmsk", &self.rwrnmsk())
            .field("twrnmsk", &self.twrnmsk())
            .field("lpb", &self.lpb())
            .field("errmsk", &self.errmsk())
            .field("boffmsk", &self.boffmsk())
            .field("pseg2", &self.pseg2())
            .field("pseg1", &self.pseg1())
            .field("rjw", &self.rjw())
            .field("presdiv", &self.presdiv())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Ctrl1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Ctrl1 {{ propseg: {=u8:?}, lom: {:?}, lbuf: {:?}, tsyn: {:?}, boffrec: {:?}, smp: {:?}, rwrnmsk: {:?}, twrnmsk: {:?}, lpb: {:?}, errmsk: {:?}, boffmsk: {:?}, pseg2: {=u8:?}, pseg1: {=u8:?}, rjw: {=u8:?}, presdiv: {=u8:?} }}",
            self.propseg(),
            self.lom(),
            self.lbuf(),
            self.tsyn(),
            self.boffrec(),
            self.smp(),
            self.rwrnmsk(),
            self.twrnmsk(),
            self.lpb(),
            self.errmsk(),
            self.boffmsk(),
            self.pseg2(),
            self.pseg1(),
            self.rjw(),
            self.presdiv()
        )
    }
}
#[doc = "Pretended Networking Control 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Ctrl1Pn(pub u32);
impl Ctrl1Pn {
    #[doc = "Filtering Combination Selection"]
    #[must_use]
    #[inline(always)]
    pub const fn fcs(&self) -> super::vals::Fcs {
        let val = (self.0 >> 0usize) & 0x03;
        super::vals::Fcs::from_bits(val as u8)
    }
    #[doc = "Filtering Combination Selection"]
    #[inline(always)]
    pub const fn set_fcs(&mut self, val: super::vals::Fcs) {
        self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
    }
    #[doc = "ID Filtering Selection"]
    #[must_use]
    #[inline(always)]
    pub const fn idfs(&self) -> super::vals::Idfs {
        let val = (self.0 >> 2usize) & 0x03;
        super::vals::Idfs::from_bits(val as u8)
    }
    #[doc = "ID Filtering Selection"]
    #[inline(always)]
    pub const fn set_idfs(&mut self, val: super::vals::Idfs) {
        self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
    }
    #[doc = "Payload Filtering Selection"]
    #[must_use]
    #[inline(always)]
    pub const fn plfs(&self) -> super::vals::Plfs {
        let val = (self.0 >> 4usize) & 0x03;
        super::vals::Plfs::from_bits(val as u8)
    }
    #[doc = "Payload Filtering Selection"]
    #[inline(always)]
    pub const fn set_plfs(&mut self, val: super::vals::Plfs) {
        self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
    }
    #[doc = "Number of Messages Matching the Same Filtering Criteria"]
    #[must_use]
    #[inline(always)]
    pub const fn nmatch(&self) -> super::vals::Nmatch {
        let val = (self.0 >> 8usize) & 0xff;
        super::vals::Nmatch::from_bits(val as u8)
    }
    #[doc = "Number of Messages Matching the Same Filtering Criteria"]
    #[inline(always)]
    pub const fn set_nmatch(&mut self, val: super::vals::Nmatch) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
    }
    #[doc = "Wake-up by Matching Flag Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn wumf_msk(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-up by Matching Flag Mask"]
    #[inline(always)]
    pub const fn set_wumf_msk(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "Wake-up by Timeout Flag Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn wtof_msk(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-up by Timeout Flag Mask"]
    #[inline(always)]
    pub const fn set_wtof_msk(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
}
impl Default for Ctrl1Pn {
    #[inline(always)]
    fn default() -> Ctrl1Pn {
        Ctrl1Pn(0)
    }
}
impl core::fmt::Debug for Ctrl1Pn {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ctrl1Pn")
            .field("fcs", &self.fcs())
            .field("idfs", &self.idfs())
            .field("plfs", &self.plfs())
            .field("nmatch", &self.nmatch())
            .field("wumf_msk", &self.wumf_msk())
            .field("wtof_msk", &self.wtof_msk())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Ctrl1Pn {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Ctrl1Pn {{ fcs: {:?}, idfs: {:?}, plfs: {:?}, nmatch: {:?}, wumf_msk: {=bool:?}, wtof_msk: {=bool:?} }}",
            self.fcs(),
            self.idfs(),
            self.plfs(),
            self.nmatch(),
            self.wumf_msk(),
            self.wtof_msk()
        )
    }
}
#[doc = "Control 2"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Ctrl2(pub u32);
impl Ctrl2 {
    #[doc = "Edge Filter Disable"]
    #[must_use]
    #[inline(always)]
    pub const fn edfltdis(&self) -> super::vals::Edfltdis {
        let val = (self.0 >> 11usize) & 0x01;
        super::vals::Edfltdis::from_bits(val as u8)
    }
    #[doc = "Edge Filter Disable"]
    #[inline(always)]
    pub const fn set_edfltdis(&mut self, val: super::vals::Edfltdis) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
    }
    #[doc = "ISO CAN FD Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn isocanfden(&self) -> super::vals::Isocanfden {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::Isocanfden::from_bits(val as u8)
    }
    #[doc = "ISO CAN FD Enable"]
    #[inline(always)]
    pub const fn set_isocanfden(&mut self, val: super::vals::Isocanfden) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Bit Timing Expansion Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn bte(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Timing Expansion Enable"]
    #[inline(always)]
    pub const fn set_bte(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Protocol Exception Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn prexcen(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "Protocol Exception Enable"]
    #[inline(always)]
    pub const fn set_prexcen(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "Entire Frame Arbitration Field Comparison Enable for RX Message Buffers"]
    #[must_use]
    #[inline(always)]
    pub const fn eacen(&self) -> super::vals::Eacen {
        let val = (self.0 >> 16usize) & 0x01;
        super::vals::Eacen::from_bits(val as u8)
    }
    #[doc = "Entire Frame Arbitration Field Comparison Enable for RX Message Buffers"]
    #[inline(always)]
    pub const fn set_eacen(&mut self, val: super::vals::Eacen) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
    }
    #[doc = "Remote Request Storing"]
    #[must_use]
    #[inline(always)]
    pub const fn rrs(&self) -> super::vals::Rrs {
        let val = (self.0 >> 17usize) & 0x01;
        super::vals::Rrs::from_bits(val as u8)
    }
    #[doc = "Remote Request Storing"]
    #[inline(always)]
    pub const fn set_rrs(&mut self, val: super::vals::Rrs) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
    }
    #[doc = "Message Buffers Reception Priority"]
    #[must_use]
    #[inline(always)]
    pub const fn mrp(&self) -> super::vals::Mrp {
        let val = (self.0 >> 18usize) & 0x01;
        super::vals::Mrp::from_bits(val as u8)
    }
    #[doc = "Message Buffers Reception Priority"]
    #[inline(always)]
    pub const fn set_mrp(&mut self, val: super::vals::Mrp) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
    }
    #[doc = "Transmission Arbitration Start Delay"]
    #[must_use]
    #[inline(always)]
    pub const fn tasd(&self) -> u8 {
        let val = (self.0 >> 19usize) & 0x1f;
        val as u8
    }
    #[doc = "Transmission Arbitration Start Delay"]
    #[inline(always)]
    pub const fn set_tasd(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 19usize)) | (((val as u32) & 0x1f) << 19usize);
    }
    #[doc = "Number of Legacy Receive FIFO Filters"]
    #[must_use]
    #[inline(always)]
    pub const fn rffn(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Number of Legacy Receive FIFO Filters"]
    #[inline(always)]
    pub const fn set_rffn(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Bus Off Done Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn boffdonemsk(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bus Off Done Interrupt Mask"]
    #[inline(always)]
    pub const fn set_boffdonemsk(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Error Interrupt Mask for Errors Detected in the Data Phase of Fast CAN FD Frames"]
    #[must_use]
    #[inline(always)]
    pub const fn errmsk_fast(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Error Interrupt Mask for Errors Detected in the Data Phase of Fast CAN FD Frames"]
    #[inline(always)]
    pub const fn set_errmsk_fast(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Ctrl2 {
    #[inline(always)]
    fn default() -> Ctrl2 {
        Ctrl2(0)
    }
}
impl core::fmt::Debug for Ctrl2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ctrl2")
            .field("edfltdis", &self.edfltdis())
            .field("isocanfden", &self.isocanfden())
            .field("bte", &self.bte())
            .field("prexcen", &self.prexcen())
            .field("eacen", &self.eacen())
            .field("rrs", &self.rrs())
            .field("mrp", &self.mrp())
            .field("tasd", &self.tasd())
            .field("rffn", &self.rffn())
            .field("boffdonemsk", &self.boffdonemsk())
            .field("errmsk_fast", &self.errmsk_fast())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Ctrl2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Ctrl2 {{ edfltdis: {:?}, isocanfden: {:?}, bte: {=bool:?}, prexcen: {=bool:?}, eacen: {:?}, rrs: {:?}, mrp: {:?}, tasd: {=u8:?}, rffn: {=u8:?}, boffdonemsk: {=bool:?}, errmsk_fast: {=bool:?} }}",
            self.edfltdis(),
            self.isocanfden(),
            self.bte(),
            self.prexcen(),
            self.eacen(),
            self.rrs(),
            self.mrp(),
            self.tasd(),
            self.rffn(),
            self.boffdonemsk(),
            self.errmsk_fast()
        )
    }
}
#[doc = "Pretended Networking Control 2"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Ctrl2Pn(pub u32);
impl Ctrl2Pn {
    #[doc = "Timeout for No Message Matching the Filtering Criteria"]
    #[must_use]
    #[inline(always)]
    pub const fn matchto(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Timeout for No Message Matching the Filtering Criteria"]
    #[inline(always)]
    pub const fn set_matchto(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
}
impl Default for Ctrl2Pn {
    #[inline(always)]
    fn default() -> Ctrl2Pn {
        Ctrl2Pn(0)
    }
}
impl core::fmt::Debug for Ctrl2Pn {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ctrl2Pn")
            .field("matchto", &self.matchto())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Ctrl2Pn {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Ctrl2Pn {{ matchto: {=u16:?} }}", self.matchto())
    }
}
#[doc = "Error Counter"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Ecr(pub u32);
impl Ecr {
    #[doc = "Transmit Error Counter"]
    #[must_use]
    #[inline(always)]
    pub const fn txerrcnt(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Transmit Error Counter"]
    #[inline(always)]
    pub const fn set_txerrcnt(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Receive Error Counter"]
    #[must_use]
    #[inline(always)]
    pub const fn rxerrcnt(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Receive Error Counter"]
    #[inline(always)]
    pub const fn set_rxerrcnt(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Transmit Error Counter for Fast Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn txerrcnt_fast(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Transmit Error Counter for Fast Bits"]
    #[inline(always)]
    pub const fn set_txerrcnt_fast(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Receive Error Counter for Fast Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn rxerrcnt_fast(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Receive Error Counter for Fast Bits"]
    #[inline(always)]
    pub const fn set_rxerrcnt_fast(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Ecr {
    #[inline(always)]
    fn default() -> Ecr {
        Ecr(0)
    }
}
impl core::fmt::Debug for Ecr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecr")
            .field("txerrcnt", &self.txerrcnt())
            .field("rxerrcnt", &self.rxerrcnt())
            .field("txerrcnt_fast", &self.txerrcnt_fast())
            .field("rxerrcnt_fast", &self.rxerrcnt_fast())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Ecr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Ecr {{ txerrcnt: {=u8:?}, rxerrcnt: {=u8:?}, txerrcnt_fast: {=u8:?}, rxerrcnt_fast: {=u8:?} }}",
            self.txerrcnt(),
            self.rxerrcnt(),
            self.txerrcnt_fast(),
            self.rxerrcnt_fast()
        )
    }
}
#[doc = "Enhanced Data Phase CAN Bit Timing"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Edcbt(pub u32);
impl Edcbt {
    #[doc = "Data Phase Segment 1"]
    #[must_use]
    #[inline(always)]
    pub const fn dtseg1(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x1f;
        val as u8
    }
    #[doc = "Data Phase Segment 1"]
    #[inline(always)]
    pub const fn set_dtseg1(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
    }
    #[doc = "Data Phase Time Segment 2"]
    #[must_use]
    #[inline(always)]
    pub const fn dtseg2(&self) -> u8 {
        let val = (self.0 >> 12usize) & 0x0f;
        val as u8
    }
    #[doc = "Data Phase Time Segment 2"]
    #[inline(always)]
    pub const fn set_dtseg2(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
    }
    #[doc = "Data Phase Resynchronization Jump Width"]
    #[must_use]
    #[inline(always)]
    pub const fn drjw(&self) -> u8 {
        let val = (self.0 >> 22usize) & 0x0f;
        val as u8
    }
    #[doc = "Data Phase Resynchronization Jump Width"]
    #[inline(always)]
    pub const fn set_drjw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 22usize)) | (((val as u32) & 0x0f) << 22usize);
    }
}
impl Default for Edcbt {
    #[inline(always)]
    fn default() -> Edcbt {
        Edcbt(0)
    }
}
impl core::fmt::Debug for Edcbt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Edcbt")
            .field("dtseg1", &self.dtseg1())
            .field("dtseg2", &self.dtseg2())
            .field("drjw", &self.drjw())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Edcbt {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Edcbt {{ dtseg1: {=u8:?}, dtseg2: {=u8:?}, drjw: {=u8:?} }}",
            self.dtseg1(),
            self.dtseg2(),
            self.drjw()
        )
    }
}
#[doc = "Enhanced Nominal CAN Bit Timing"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Encbt(pub u32);
impl Encbt {
    #[doc = "Nominal Time Segment 1"]
    #[must_use]
    #[inline(always)]
    pub const fn ntseg1(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Nominal Time Segment 1"]
    #[inline(always)]
    pub const fn set_ntseg1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Nominal Time Segment 2"]
    #[must_use]
    #[inline(always)]
    pub const fn ntseg2(&self) -> u8 {
        let val = (self.0 >> 12usize) & 0x7f;
        val as u8
    }
    #[doc = "Nominal Time Segment 2"]
    #[inline(always)]
    pub const fn set_ntseg2(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 12usize)) | (((val as u32) & 0x7f) << 12usize);
    }
    #[doc = "Nominal Resynchronization Jump Width"]
    #[must_use]
    #[inline(always)]
    pub const fn nrjw(&self) -> u8 {
        let val = (self.0 >> 22usize) & 0x7f;
        val as u8
    }
    #[doc = "Nominal Resynchronization Jump Width"]
    #[inline(always)]
    pub const fn set_nrjw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 22usize)) | (((val as u32) & 0x7f) << 22usize);
    }
}
impl Default for Encbt {
    #[inline(always)]
    fn default() -> Encbt {
        Encbt(0)
    }
}
impl core::fmt::Debug for Encbt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Encbt")
            .field("ntseg1", &self.ntseg1())
            .field("ntseg2", &self.ntseg2())
            .field("nrjw", &self.nrjw())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Encbt {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Encbt {{ ntseg1: {=u8:?}, ntseg2: {=u8:?}, nrjw: {=u8:?} }}",
            self.ntseg1(),
            self.ntseg2(),
            self.nrjw()
        )
    }
}
#[doc = "Enhanced CAN Bit Timing Prescalers"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Eprs(pub u32);
impl Eprs {
    #[doc = "Extended Nominal Prescaler Division Factor"]
    #[must_use]
    #[inline(always)]
    pub const fn enpresdiv(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x03ff;
        val as u16
    }
    #[doc = "Extended Nominal Prescaler Division Factor"]
    #[inline(always)]
    pub const fn set_enpresdiv(&mut self, val: u16) {
        self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
    }
    #[doc = "Extended Data Phase Prescaler Division Factor"]
    #[must_use]
    #[inline(always)]
    pub const fn edpresdiv(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0x03ff;
        val as u16
    }
    #[doc = "Extended Data Phase Prescaler Division Factor"]
    #[inline(always)]
    pub const fn set_edpresdiv(&mut self, val: u16) {
        self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
    }
}
impl Default for Eprs {
    #[inline(always)]
    fn default() -> Eprs {
        Eprs(0)
    }
}
impl core::fmt::Debug for Eprs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eprs")
            .field("enpresdiv", &self.enpresdiv())
            .field("edpresdiv", &self.edpresdiv())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Eprs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Eprs {{ enpresdiv: {=u16:?}, edpresdiv: {=u16:?} }}",
            self.enpresdiv(),
            self.edpresdiv()
        )
    }
}
#[doc = "Enhanced RX FIFO Control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Erfcr(pub u32);
impl Erfcr {
    #[doc = "Enhanced RX FIFO Watermark"]
    #[must_use]
    #[inline(always)]
    pub const fn erfwm(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x1f;
        val as u8
    }
    #[doc = "Enhanced RX FIFO Watermark"]
    #[inline(always)]
    pub const fn set_erfwm(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
    }
    #[doc = "Number of Enhanced RX FIFO Filter Elements"]
    #[must_use]
    #[inline(always)]
    pub const fn nfe(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x3f;
        val as u8
    }
    #[doc = "Number of Enhanced RX FIFO Filter Elements"]
    #[inline(always)]
    pub const fn set_nfe(&mut self, val: u8) {
        self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
    }
    #[doc = "Number of Extended ID Filter Elements"]
    #[must_use]
    #[inline(always)]
    pub const fn nexif(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x7f;
        val as u8
    }
    #[doc = "Number of Extended ID Filter Elements"]
    #[inline(always)]
    pub const fn set_nexif(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
    }
    #[doc = "DMA Last Word"]
    #[must_use]
    #[inline(always)]
    pub const fn dmalw(&self) -> u8 {
        let val = (self.0 >> 26usize) & 0x1f;
        val as u8
    }
    #[doc = "DMA Last Word"]
    #[inline(always)]
    pub const fn set_dmalw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 26usize)) | (((val as u32) & 0x1f) << 26usize);
    }
    #[doc = "Enhanced RX FIFO enable"]
    #[must_use]
    #[inline(always)]
    pub const fn erfen(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO enable"]
    #[inline(always)]
    pub const fn set_erfen(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Erfcr {
    #[inline(always)]
    fn default() -> Erfcr {
        Erfcr(0)
    }
}
impl core::fmt::Debug for Erfcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Erfcr")
            .field("erfwm", &self.erfwm())
            .field("nfe", &self.nfe())
            .field("nexif", &self.nexif())
            .field("dmalw", &self.dmalw())
            .field("erfen", &self.erfen())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Erfcr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Erfcr {{ erfwm: {=u8:?}, nfe: {=u8:?}, nexif: {=u8:?}, dmalw: {=u8:?}, erfen: {=bool:?} }}",
            self.erfwm(),
            self.nfe(),
            self.nexif(),
            self.dmalw(),
            self.erfen()
        )
    }
}
#[doc = "Enhanced RX FIFO Filter Element"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Erffel(pub u32);
impl Erffel {
    #[doc = "Filter Element Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn fel(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "Filter Element Bits"]
    #[inline(always)]
    pub const fn set_fel(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Erffel {
    #[inline(always)]
    fn default() -> Erffel {
        Erffel(0)
    }
}
impl core::fmt::Debug for Erffel {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Erffel").field("fel", &self.fel()).finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Erffel {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Erffel {{ fel: {=u32:?} }}", self.fel())
    }
}
#[doc = "Enhanced RX FIFO Interrupt Enable"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Erfier(pub u32);
impl Erfier {
    #[doc = "Enhanced RX FIFO Data Available Interrupt Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn erfdaie(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Data Available Interrupt Enable"]
    #[inline(always)]
    pub const fn set_erfdaie(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "Enhanced RX FIFO Watermark Indication Interrupt Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn erfwmiie(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Watermark Indication Interrupt Enable"]
    #[inline(always)]
    pub const fn set_erfwmiie(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Enhanced RX FIFO Overflow Interrupt Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn erfovfie(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Overflow Interrupt Enable"]
    #[inline(always)]
    pub const fn set_erfovfie(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Enhanced RX FIFO Underflow Interrupt Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn erfufwie(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Underflow Interrupt Enable"]
    #[inline(always)]
    pub const fn set_erfufwie(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Erfier {
    #[inline(always)]
    fn default() -> Erfier {
        Erfier(0)
    }
}
impl core::fmt::Debug for Erfier {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Erfier")
            .field("erfdaie", &self.erfdaie())
            .field("erfwmiie", &self.erfwmiie())
            .field("erfovfie", &self.erfovfie())
            .field("erfufwie", &self.erfufwie())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Erfier {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Erfier {{ erfdaie: {=bool:?}, erfwmiie: {=bool:?}, erfovfie: {=bool:?}, erfufwie: {=bool:?} }}",
            self.erfdaie(),
            self.erfwmiie(),
            self.erfovfie(),
            self.erfufwie()
        )
    }
}
#[doc = "Enhanced RX FIFO Status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Erfsr(pub u32);
impl Erfsr {
    #[doc = "Enhanced RX FIFO Elements"]
    #[must_use]
    #[inline(always)]
    pub const fn erfel(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x3f;
        val as u8
    }
    #[doc = "Enhanced RX FIFO Elements"]
    #[inline(always)]
    pub const fn set_erfel(&mut self, val: u8) {
        self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
    }
    #[doc = "Enhanced RX FIFO Full Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erff(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Full Flag"]
    #[inline(always)]
    pub const fn set_erff(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "Enhanced RX FIFO Empty Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erfe(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Empty Flag"]
    #[inline(always)]
    pub const fn set_erfe(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "Enhanced RX FIFO Clear"]
    #[must_use]
    #[inline(always)]
    pub const fn erfclr(&self) -> super::vals::Erfclr {
        let val = (self.0 >> 27usize) & 0x01;
        super::vals::Erfclr::from_bits(val as u8)
    }
    #[doc = "Enhanced RX FIFO Clear"]
    #[inline(always)]
    pub const fn set_erfclr(&mut self, val: super::vals::Erfclr) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
    }
    #[doc = "Enhanced RX FIFO Data Available Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erfda(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Data Available Flag"]
    #[inline(always)]
    pub const fn set_erfda(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "Enhanced RX FIFO Watermark Indication Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erfwmi(&self) -> super::vals::Erfwmi {
        let val = (self.0 >> 29usize) & 0x01;
        super::vals::Erfwmi::from_bits(val as u8)
    }
    #[doc = "Enhanced RX FIFO Watermark Indication Flag"]
    #[inline(always)]
    pub const fn set_erfwmi(&mut self, val: super::vals::Erfwmi) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
    }
    #[doc = "Enhanced RX FIFO Overflow Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erfovf(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Overflow Flag"]
    #[inline(always)]
    pub const fn set_erfovf(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Enhanced RX FIFO Underflow Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn erfufw(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Enhanced RX FIFO Underflow Flag"]
    #[inline(always)]
    pub const fn set_erfufw(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Erfsr {
    #[inline(always)]
    fn default() -> Erfsr {
        Erfsr(0)
    }
}
impl core::fmt::Debug for Erfsr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Erfsr")
            .field("erfel", &self.erfel())
            .field("erff", &self.erff())
            .field("erfe", &self.erfe())
            .field("erfclr", &self.erfclr())
            .field("erfda", &self.erfda())
            .field("erfwmi", &self.erfwmi())
            .field("erfovf", &self.erfovf())
            .field("erfufw", &self.erfufw())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Erfsr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Erfsr {{ erfel: {=u8:?}, erff: {=bool:?}, erfe: {=bool:?}, erfclr: {:?}, erfda: {=bool:?}, erfwmi: {:?}, erfovf: {=bool:?}, erfufw: {=bool:?} }}",
            self.erfel(),
            self.erff(),
            self.erfe(),
            self.erfclr(),
            self.erfda(),
            self.erfwmi(),
            self.erfovf(),
            self.erfufw()
        )
    }
}
#[doc = "Error and Status 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Esr1(pub u32);
impl Esr1 {
    #[doc = "Wake-up Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn wakint(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-up Interrupt Flag"]
    #[inline(always)]
    pub const fn set_wakint(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "Error Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn errint(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "Error Interrupt Flag"]
    #[inline(always)]
    pub const fn set_errint(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "Bus Off Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn boffint(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "Bus Off Interrupt Flag"]
    #[inline(always)]
    pub const fn set_boffint(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "FlexCAN in Reception Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn rx(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "FlexCAN in Reception Flag"]
    #[inline(always)]
    pub const fn set_rx(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "Fault Confinement State"]
    #[must_use]
    #[inline(always)]
    pub const fn fltconf(&self) -> super::vals::Fltconf {
        let val = (self.0 >> 4usize) & 0x03;
        super::vals::Fltconf::from_bits(val as u8)
    }
    #[doc = "Fault Confinement State"]
    #[inline(always)]
    pub const fn set_fltconf(&mut self, val: super::vals::Fltconf) {
        self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
    }
    #[doc = "FlexCAN In Transmission"]
    #[must_use]
    #[inline(always)]
    pub const fn tx(&self) -> super::vals::Tx {
        let val = (self.0 >> 6usize) & 0x01;
        super::vals::Tx::from_bits(val as u8)
    }
    #[doc = "FlexCAN In Transmission"]
    #[inline(always)]
    pub const fn set_tx(&mut self, val: super::vals::Tx) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
    }
    #[doc = "Idle"]
    #[must_use]
    #[inline(always)]
    pub const fn idle(&self) -> super::vals::Idle {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Idle::from_bits(val as u8)
    }
    #[doc = "Idle"]
    #[inline(always)]
    pub const fn set_idle(&mut self, val: super::vals::Idle) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "RX Error Warning Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn rxwrn(&self) -> super::vals::Rxwrn {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::Rxwrn::from_bits(val as u8)
    }
    #[doc = "RX Error Warning Flag"]
    #[inline(always)]
    pub const fn set_rxwrn(&mut self, val: super::vals::Rxwrn) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "TX Error Warning Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn txwrn(&self) -> super::vals::Txwrn {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::Txwrn::from_bits(val as u8)
    }
    #[doc = "TX Error Warning Flag"]
    #[inline(always)]
    pub const fn set_txwrn(&mut self, val: super::vals::Txwrn) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Stuffing Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn stferr(&self) -> super::vals::Stferr {
        let val = (self.0 >> 10usize) & 0x01;
        super::vals::Stferr::from_bits(val as u8)
    }
    #[doc = "Stuffing Error Flag"]
    #[inline(always)]
    pub const fn set_stferr(&mut self, val: super::vals::Stferr) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
    }
    #[doc = "Form Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn frmerr(&self) -> super::vals::Frmerr {
        let val = (self.0 >> 11usize) & 0x01;
        super::vals::Frmerr::from_bits(val as u8)
    }
    #[doc = "Form Error Flag"]
    #[inline(always)]
    pub const fn set_frmerr(&mut self, val: super::vals::Frmerr) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
    }
    #[doc = "Cyclic Redundancy Check Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn crcerr(&self) -> super::vals::Crcerr {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::Crcerr::from_bits(val as u8)
    }
    #[doc = "Cyclic Redundancy Check Error Flag"]
    #[inline(always)]
    pub const fn set_crcerr(&mut self, val: super::vals::Crcerr) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Acknowledge Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn ackerr(&self) -> super::vals::Ackerr {
        let val = (self.0 >> 13usize) & 0x01;
        super::vals::Ackerr::from_bits(val as u8)
    }
    #[doc = "Acknowledge Error Flag"]
    #[inline(always)]
    pub const fn set_ackerr(&mut self, val: super::vals::Ackerr) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
    }
    #[doc = "Bit0 Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn bit0err(&self) -> super::vals::Bit0err {
        let val = (self.0 >> 14usize) & 0x01;
        super::vals::Bit0err::from_bits(val as u8)
    }
    #[doc = "Bit0 Error Flag"]
    #[inline(always)]
    pub const fn set_bit0err(&mut self, val: super::vals::Bit0err) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
    }
    #[doc = "Bit1 Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn bit1err(&self) -> super::vals::Bit1err {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::Bit1err::from_bits(val as u8)
    }
    #[doc = "Bit1 Error Flag"]
    #[inline(always)]
    pub const fn set_bit1err(&mut self, val: super::vals::Bit1err) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "RX Warning Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn rwrnint(&self) -> super::vals::Rwrnint {
        let val = (self.0 >> 16usize) & 0x01;
        super::vals::Rwrnint::from_bits(val as u8)
    }
    #[doc = "RX Warning Interrupt Flag"]
    #[inline(always)]
    pub const fn set_rwrnint(&mut self, val: super::vals::Rwrnint) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
    }
    #[doc = "TX Warning Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn twrnint(&self) -> super::vals::Twrnint {
        let val = (self.0 >> 17usize) & 0x01;
        super::vals::Twrnint::from_bits(val as u8)
    }
    #[doc = "TX Warning Interrupt Flag"]
    #[inline(always)]
    pub const fn set_twrnint(&mut self, val: super::vals::Twrnint) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
    }
    #[doc = "CAN Synchronization Status Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn synch(&self) -> super::vals::Synch {
        let val = (self.0 >> 18usize) & 0x01;
        super::vals::Synch::from_bits(val as u8)
    }
    #[doc = "CAN Synchronization Status Flag"]
    #[inline(always)]
    pub const fn set_synch(&mut self, val: super::vals::Synch) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
    }
    #[doc = "Bus Off Done Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn boffdoneint(&self) -> super::vals::Boffdoneint {
        let val = (self.0 >> 19usize) & 0x01;
        super::vals::Boffdoneint::from_bits(val as u8)
    }
    #[doc = "Bus Off Done Interrupt Flag"]
    #[inline(always)]
    pub const fn set_boffdoneint(&mut self, val: super::vals::Boffdoneint) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
    }
    #[doc = "Fast Error Interrupt Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn errint_fast(&self) -> super::vals::ErrintFast {
        let val = (self.0 >> 20usize) & 0x01;
        super::vals::ErrintFast::from_bits(val as u8)
    }
    #[doc = "Fast Error Interrupt Flag"]
    #[inline(always)]
    pub const fn set_errint_fast(&mut self, val: super::vals::ErrintFast) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
    }
    #[doc = "Error Overrun Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn errovr(&self) -> super::vals::Errovr {
        let val = (self.0 >> 21usize) & 0x01;
        super::vals::Errovr::from_bits(val as u8)
    }
    #[doc = "Error Overrun Flag"]
    #[inline(always)]
    pub const fn set_errovr(&mut self, val: super::vals::Errovr) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
    }
    #[doc = "Fast Stuffing Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn stferr_fast(&self) -> super::vals::StferrFast {
        let val = (self.0 >> 26usize) & 0x01;
        super::vals::StferrFast::from_bits(val as u8)
    }
    #[doc = "Fast Stuffing Error Flag"]
    #[inline(always)]
    pub const fn set_stferr_fast(&mut self, val: super::vals::StferrFast) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
    }
    #[doc = "Fast Form Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn frmerr_fast(&self) -> super::vals::FrmerrFast {
        let val = (self.0 >> 27usize) & 0x01;
        super::vals::FrmerrFast::from_bits(val as u8)
    }
    #[doc = "Fast Form Error Flag"]
    #[inline(always)]
    pub const fn set_frmerr_fast(&mut self, val: super::vals::FrmerrFast) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
    }
    #[doc = "Fast Cyclic Redundancy Check Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn crcerr_fast(&self) -> super::vals::CrcerrFast {
        let val = (self.0 >> 28usize) & 0x01;
        super::vals::CrcerrFast::from_bits(val as u8)
    }
    #[doc = "Fast Cyclic Redundancy Check Error Flag"]
    #[inline(always)]
    pub const fn set_crcerr_fast(&mut self, val: super::vals::CrcerrFast) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
    }
    #[doc = "Fast Bit0 Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn bit0err_fast(&self) -> super::vals::Bit0errFast {
        let val = (self.0 >> 30usize) & 0x01;
        super::vals::Bit0errFast::from_bits(val as u8)
    }
    #[doc = "Fast Bit0 Error Flag"]
    #[inline(always)]
    pub const fn set_bit0err_fast(&mut self, val: super::vals::Bit0errFast) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
    }
    #[doc = "Fast Bit1 Error Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn bit1err_fast(&self) -> super::vals::Bit1errFast {
        let val = (self.0 >> 31usize) & 0x01;
        super::vals::Bit1errFast::from_bits(val as u8)
    }
    #[doc = "Fast Bit1 Error Flag"]
    #[inline(always)]
    pub const fn set_bit1err_fast(&mut self, val: super::vals::Bit1errFast) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
    }
}
impl Default for Esr1 {
    #[inline(always)]
    fn default() -> Esr1 {
        Esr1(0)
    }
}
impl core::fmt::Debug for Esr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Esr1")
            .field("wakint", &self.wakint())
            .field("errint", &self.errint())
            .field("boffint", &self.boffint())
            .field("rx", &self.rx())
            .field("fltconf", &self.fltconf())
            .field("tx", &self.tx())
            .field("idle", &self.idle())
            .field("rxwrn", &self.rxwrn())
            .field("txwrn", &self.txwrn())
            .field("stferr", &self.stferr())
            .field("frmerr", &self.frmerr())
            .field("crcerr", &self.crcerr())
            .field("ackerr", &self.ackerr())
            .field("bit0err", &self.bit0err())
            .field("bit1err", &self.bit1err())
            .field("rwrnint", &self.rwrnint())
            .field("twrnint", &self.twrnint())
            .field("synch", &self.synch())
            .field("boffdoneint", &self.boffdoneint())
            .field("errint_fast", &self.errint_fast())
            .field("errovr", &self.errovr())
            .field("stferr_fast", &self.stferr_fast())
            .field("frmerr_fast", &self.frmerr_fast())
            .field("crcerr_fast", &self.crcerr_fast())
            .field("bit0err_fast", &self.bit0err_fast())
            .field("bit1err_fast", &self.bit1err_fast())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Esr1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Esr1 {{ wakint: {=bool:?}, errint: {=bool:?}, boffint: {=bool:?}, rx: {=bool:?}, fltconf: {:?}, tx: {:?}, idle: {:?}, rxwrn: {:?}, txwrn: {:?}, stferr: {:?}, frmerr: {:?}, crcerr: {:?}, ackerr: {:?}, bit0err: {:?}, bit1err: {:?}, rwrnint: {:?}, twrnint: {:?}, synch: {:?}, boffdoneint: {:?}, errint_fast: {:?}, errovr: {:?}, stferr_fast: {:?}, frmerr_fast: {:?}, crcerr_fast: {:?}, bit0err_fast: {:?}, bit1err_fast: {:?} }}",
            self.wakint(),
            self.errint(),
            self.boffint(),
            self.rx(),
            self.fltconf(),
            self.tx(),
            self.idle(),
            self.rxwrn(),
            self.txwrn(),
            self.stferr(),
            self.frmerr(),
            self.crcerr(),
            self.ackerr(),
            self.bit0err(),
            self.bit1err(),
            self.rwrnint(),
            self.twrnint(),
            self.synch(),
            self.boffdoneint(),
            self.errint_fast(),
            self.errovr(),
            self.stferr_fast(),
            self.frmerr_fast(),
            self.crcerr_fast(),
            self.bit0err_fast(),
            self.bit1err_fast()
        )
    }
}
#[doc = "Error and Status 2"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Esr2(pub u32);
impl Esr2 {
    #[doc = "Inactive Message Buffer"]
    #[must_use]
    #[inline(always)]
    pub const fn imb(&self) -> super::vals::Imb {
        let val = (self.0 >> 13usize) & 0x01;
        super::vals::Imb::from_bits(val as u8)
    }
    #[doc = "Inactive Message Buffer"]
    #[inline(always)]
    pub const fn set_imb(&mut self, val: super::vals::Imb) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
    }
    #[doc = "Valid Priority Status"]
    #[must_use]
    #[inline(always)]
    pub const fn vps(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "Valid Priority Status"]
    #[inline(always)]
    pub const fn set_vps(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "Lowest Priority TX Message Buffer"]
    #[must_use]
    #[inline(always)]
    pub const fn lptm(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x7f;
        val as u8
    }
    #[doc = "Lowest Priority TX Message Buffer"]
    #[inline(always)]
    pub const fn set_lptm(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
    }
}
impl Default for Esr2 {
    #[inline(always)]
    fn default() -> Esr2 {
        Esr2(0)
    }
}
impl core::fmt::Debug for Esr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Esr2")
            .field("imb", &self.imb())
            .field("vps", &self.vps())
            .field("lptm", &self.lptm())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Esr2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Esr2 {{ imb: {:?}, vps: {=bool:?}, lptm: {=u8:?} }}",
            self.imb(),
            self.vps(),
            self.lptm()
        )
    }
}
#[doc = "Enhanced Transceiver Delay Compensation"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Etdc(pub u32);
impl Etdc {
    #[doc = "Enhanced Transceiver Delay Compensation Value"]
    #[must_use]
    #[inline(always)]
    pub const fn etdcval(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Enhanced Transceiver Delay Compensation Value"]
    #[inline(always)]
    pub const fn set_etdcval(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Transceiver Delay Compensation Fail"]
    #[must_use]
    #[inline(always)]
    pub const fn etdcfail(&self) -> super::vals::Etdcfail {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::Etdcfail::from_bits(val as u8)
    }
    #[doc = "Transceiver Delay Compensation Fail"]
    #[inline(always)]
    pub const fn set_etdcfail(&mut self, val: super::vals::Etdcfail) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "Enhanced Transceiver Delay Compensation Offset"]
    #[must_use]
    #[inline(always)]
    pub const fn etdcoff(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x7f;
        val as u8
    }
    #[doc = "Enhanced Transceiver Delay Compensation Offset"]
    #[inline(always)]
    pub const fn set_etdcoff(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
    }
    #[doc = "Transceiver Delay Measurement Disable"]
    #[must_use]
    #[inline(always)]
    pub const fn tdmdis(&self) -> super::vals::Tdmdis {
        let val = (self.0 >> 30usize) & 0x01;
        super::vals::Tdmdis::from_bits(val as u8)
    }
    #[doc = "Transceiver Delay Measurement Disable"]
    #[inline(always)]
    pub const fn set_tdmdis(&mut self, val: super::vals::Tdmdis) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
    }
    #[doc = "Transceiver Delay Compensation Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn etdcen(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Transceiver Delay Compensation Enable"]
    #[inline(always)]
    pub const fn set_etdcen(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Etdc {
    #[inline(always)]
    fn default() -> Etdc {
        Etdc(0)
    }
}
impl core::fmt::Debug for Etdc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Etdc")
            .field("etdcval", &self.etdcval())
            .field("etdcfail", &self.etdcfail())
            .field("etdcoff", &self.etdcoff())
            .field("tdmdis", &self.tdmdis())
            .field("etdcen", &self.etdcen())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Etdc {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Etdc {{ etdcval: {=u8:?}, etdcfail: {:?}, etdcoff: {=u8:?}, tdmdis: {:?}, etdcen: {=bool:?} }}",
            self.etdcval(),
            self.etdcfail(),
            self.etdcoff(),
            self.tdmdis(),
            self.etdcen()
        )
    }
}
#[doc = "CAN FD Bit Timing"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Fdcbt(pub u32);
impl Fdcbt {
    #[doc = "Fast Phase Segment 2"]
    #[must_use]
    #[inline(always)]
    pub const fn fpseg2(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x07;
        val as u8
    }
    #[doc = "Fast Phase Segment 2"]
    #[inline(always)]
    pub const fn set_fpseg2(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
    }
    #[doc = "Fast Phase Segment 1"]
    #[must_use]
    #[inline(always)]
    pub const fn fpseg1(&self) -> u8 {
        let val = (self.0 >> 5usize) & 0x07;
        val as u8
    }
    #[doc = "Fast Phase Segment 1"]
    #[inline(always)]
    pub const fn set_fpseg1(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
    }
    #[doc = "Fast Propagation Segment"]
    #[must_use]
    #[inline(always)]
    pub const fn fpropseg(&self) -> u8 {
        let val = (self.0 >> 10usize) & 0x1f;
        val as u8
    }
    #[doc = "Fast Propagation Segment"]
    #[inline(always)]
    pub const fn set_fpropseg(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 10usize)) | (((val as u32) & 0x1f) << 10usize);
    }
    #[doc = "Fast Resync Jump Width"]
    #[must_use]
    #[inline(always)]
    pub const fn frjw(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x07;
        val as u8
    }
    #[doc = "Fast Resync Jump Width"]
    #[inline(always)]
    pub const fn set_frjw(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
    }
    #[doc = "Fast Prescaler Division Factor"]
    #[must_use]
    #[inline(always)]
    pub const fn fpresdiv(&self) -> u16 {
        let val = (self.0 >> 20usize) & 0x03ff;
        val as u16
    }
    #[doc = "Fast Prescaler Division Factor"]
    #[inline(always)]
    pub const fn set_fpresdiv(&mut self, val: u16) {
        self.0 = (self.0 & !(0x03ff << 20usize)) | (((val as u32) & 0x03ff) << 20usize);
    }
}
impl Default for Fdcbt {
    #[inline(always)]
    fn default() -> Fdcbt {
        Fdcbt(0)
    }
}
impl core::fmt::Debug for Fdcbt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fdcbt")
            .field("fpseg2", &self.fpseg2())
            .field("fpseg1", &self.fpseg1())
            .field("fpropseg", &self.fpropseg())
            .field("frjw", &self.frjw())
            .field("fpresdiv", &self.fpresdiv())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Fdcbt {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Fdcbt {{ fpseg2: {=u8:?}, fpseg1: {=u8:?}, fpropseg: {=u8:?}, frjw: {=u8:?}, fpresdiv: {=u16:?} }}",
            self.fpseg2(),
            self.fpseg1(),
            self.fpropseg(),
            self.frjw(),
            self.fpresdiv()
        )
    }
}
#[doc = "CAN FD CRC"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Fdcrc(pub u32);
impl Fdcrc {
    #[doc = "Extended Transmitted CRC value"]
    #[must_use]
    #[inline(always)]
    pub const fn fd_txcrc(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x001f_ffff;
        val as u32
    }
    #[doc = "Extended Transmitted CRC value"]
    #[inline(always)]
    pub const fn set_fd_txcrc(&mut self, val: u32) {
        self.0 = (self.0 & !(0x001f_ffff << 0usize)) | (((val as u32) & 0x001f_ffff) << 0usize);
    }
    #[doc = "CRC Message Buffer Number for FD_TXCRC"]
    #[must_use]
    #[inline(always)]
    pub const fn fd_mbcrc(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x7f;
        val as u8
    }
    #[doc = "CRC Message Buffer Number for FD_TXCRC"]
    #[inline(always)]
    pub const fn set_fd_mbcrc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 24usize)) | (((val as u32) & 0x7f) << 24usize);
    }
}
impl Default for Fdcrc {
    #[inline(always)]
    fn default() -> Fdcrc {
        Fdcrc(0)
    }
}
impl core::fmt::Debug for Fdcrc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fdcrc")
            .field("fd_txcrc", &self.fd_txcrc())
            .field("fd_mbcrc", &self.fd_mbcrc())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Fdcrc {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Fdcrc {{ fd_txcrc: {=u32:?}, fd_mbcrc: {=u8:?} }}",
            self.fd_txcrc(),
            self.fd_mbcrc()
        )
    }
}
#[doc = "CAN FD Control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Fdctrl(pub u32);
impl Fdctrl {
    #[doc = "Transceiver Delay Compensation Value"]
    #[must_use]
    #[inline(always)]
    pub const fn tdcval(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x3f;
        val as u8
    }
    #[doc = "Transceiver Delay Compensation Value"]
    #[inline(always)]
    pub const fn set_tdcval(&mut self, val: u8) {
        self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
    }
    #[doc = "Transceiver Delay Compensation Offset"]
    #[must_use]
    #[inline(always)]
    pub const fn tdcoff(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x1f;
        val as u8
    }
    #[doc = "Transceiver Delay Compensation Offset"]
    #[inline(always)]
    pub const fn set_tdcoff(&mut self, val: u8) {
        self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
    }
    #[doc = "Transceiver Delay Compensation Fail"]
    #[must_use]
    #[inline(always)]
    pub const fn tdcfail(&self) -> super::vals::Tdcfail {
        let val = (self.0 >> 14usize) & 0x01;
        super::vals::Tdcfail::from_bits(val as u8)
    }
    #[doc = "Transceiver Delay Compensation Fail"]
    #[inline(always)]
    pub const fn set_tdcfail(&mut self, val: super::vals::Tdcfail) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
    }
    #[doc = "Transceiver Delay Compensation Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn tdcen(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Transceiver Delay Compensation Enable"]
    #[inline(always)]
    pub const fn set_tdcen(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Message Buffer Data Size for Region 0"]
    #[must_use]
    #[inline(always)]
    pub const fn mbdsr0(&self) -> super::vals::Mbdsr0 {
        let val = (self.0 >> 16usize) & 0x03;
        super::vals::Mbdsr0::from_bits(val as u8)
    }
    #[doc = "Message Buffer Data Size for Region 0"]
    #[inline(always)]
    pub const fn set_mbdsr0(&mut self, val: super::vals::Mbdsr0) {
        self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
    }
    #[doc = "Bit Rate Switch Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn fdrate(&self) -> super::vals::Fdrate {
        let val = (self.0 >> 31usize) & 0x01;
        super::vals::Fdrate::from_bits(val as u8)
    }
    #[doc = "Bit Rate Switch Enable"]
    #[inline(always)]
    pub const fn set_fdrate(&mut self, val: super::vals::Fdrate) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
    }
}
impl Default for Fdctrl {
    #[inline(always)]
    fn default() -> Fdctrl {
        Fdctrl(0)
    }
}
impl core::fmt::Debug for Fdctrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fdctrl")
            .field("tdcval", &self.tdcval())
            .field("tdcoff", &self.tdcoff())
            .field("tdcfail", &self.tdcfail())
            .field("tdcen", &self.tdcen())
            .field("mbdsr0", &self.mbdsr0())
            .field("fdrate", &self.fdrate())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Fdctrl {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Fdctrl {{ tdcval: {=u8:?}, tdcoff: {=u8:?}, tdcfail: {:?}, tdcen: {=bool:?}, mbdsr0: {:?}, fdrate: {:?} }}",
            self.tdcval(),
            self.tdcoff(),
            self.tdcfail(),
            self.tdcen(),
            self.mbdsr0(),
            self.fdrate()
        )
    }
}
#[doc = "Pretended Networking Data Length Code (DLC) Filter"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct FltDlc(pub u32);
impl FltDlc {
    #[doc = "Upper Limit for Length of Data Bytes Filter"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_dlc_hi(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x0f;
        val as u8
    }
    #[doc = "Upper Limit for Length of Data Bytes Filter"]
    #[inline(always)]
    pub const fn set_flt_dlc_hi(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
    }
    #[doc = "Lower Limit for Length of Data Bytes Filter"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_dlc_lo(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Lower Limit for Length of Data Bytes Filter"]
    #[inline(always)]
    pub const fn set_flt_dlc_lo(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
}
impl Default for FltDlc {
    #[inline(always)]
    fn default() -> FltDlc {
        FltDlc(0)
    }
}
impl core::fmt::Debug for FltDlc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FltDlc")
            .field("flt_dlc_hi", &self.flt_dlc_hi())
            .field("flt_dlc_lo", &self.flt_dlc_lo())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for FltDlc {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "FltDlc {{ flt_dlc_hi: {=u8:?}, flt_dlc_lo: {=u8:?} }}",
            self.flt_dlc_hi(),
            self.flt_dlc_lo()
        )
    }
}
#[doc = "Pretended Networking ID Filter 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct FltId1(pub u32);
impl FltId1 {
    #[doc = "ID Filter 1 for Pretended Networking filtering"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_id1(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x1fff_ffff;
        val as u32
    }
    #[doc = "ID Filter 1 for Pretended Networking filtering"]
    #[inline(always)]
    pub const fn set_flt_id1(&mut self, val: u32) {
        self.0 = (self.0 & !(0x1fff_ffff << 0usize)) | (((val as u32) & 0x1fff_ffff) << 0usize);
    }
    #[doc = "Remote Transmission Request Filter"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_rtr(&self) -> super::vals::FltRtr {
        let val = (self.0 >> 29usize) & 0x01;
        super::vals::FltRtr::from_bits(val as u8)
    }
    #[doc = "Remote Transmission Request Filter"]
    #[inline(always)]
    pub const fn set_flt_rtr(&mut self, val: super::vals::FltRtr) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
    }
    #[doc = "ID Extended Filter"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_ide(&self) -> super::vals::FltIde {
        let val = (self.0 >> 30usize) & 0x01;
        super::vals::FltIde::from_bits(val as u8)
    }
    #[doc = "ID Extended Filter"]
    #[inline(always)]
    pub const fn set_flt_ide(&mut self, val: super::vals::FltIde) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
    }
}
impl Default for FltId1 {
    #[inline(always)]
    fn default() -> FltId1 {
        FltId1(0)
    }
}
impl core::fmt::Debug for FltId1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FltId1")
            .field("flt_id1", &self.flt_id1())
            .field("flt_rtr", &self.flt_rtr())
            .field("flt_ide", &self.flt_ide())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for FltId1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "FltId1 {{ flt_id1: {=u32:?}, flt_rtr: {:?}, flt_ide: {:?} }}",
            self.flt_id1(),
            self.flt_rtr(),
            self.flt_ide()
        )
    }
}
#[doc = "Pretended Networking ID Filter 2 or ID Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct FltId2Idmask(pub u32);
impl FltId2Idmask {
    #[doc = "ID Filter 2 for Pretended Networking Filtering or ID Mask Bits for Pretended Networking ID Filtering"]
    #[must_use]
    #[inline(always)]
    pub const fn flt_id2_idmask(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x1fff_ffff;
        val as u32
    }
    #[doc = "ID Filter 2 for Pretended Networking Filtering or ID Mask Bits for Pretended Networking ID Filtering"]
    #[inline(always)]
    pub const fn set_flt_id2_idmask(&mut self, val: u32) {
        self.0 = (self.0 & !(0x1fff_ffff << 0usize)) | (((val as u32) & 0x1fff_ffff) << 0usize);
    }
    #[doc = "Remote Transmission Request Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn rtr_msk(&self) -> super::vals::RtrMsk {
        let val = (self.0 >> 29usize) & 0x01;
        super::vals::RtrMsk::from_bits(val as u8)
    }
    #[doc = "Remote Transmission Request Mask"]
    #[inline(always)]
    pub const fn set_rtr_msk(&mut self, val: super::vals::RtrMsk) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
    }
    #[doc = "ID Extended Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn ide_msk(&self) -> super::vals::IdeMsk {
        let val = (self.0 >> 30usize) & 0x01;
        super::vals::IdeMsk::from_bits(val as u8)
    }
    #[doc = "ID Extended Mask"]
    #[inline(always)]
    pub const fn set_ide_msk(&mut self, val: super::vals::IdeMsk) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
    }
}
impl Default for FltId2Idmask {
    #[inline(always)]
    fn default() -> FltId2Idmask {
        FltId2Idmask(0)
    }
}
impl core::fmt::Debug for FltId2Idmask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FltId2Idmask")
            .field("flt_id2_idmask", &self.flt_id2_idmask())
            .field("rtr_msk", &self.rtr_msk())
            .field("ide_msk", &self.ide_msk())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for FltId2Idmask {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "FltId2Idmask {{ flt_id2_idmask: {=u32:?}, rtr_msk: {:?}, ide_msk: {:?} }}",
            self.flt_id2_idmask(),
            self.rtr_msk(),
            self.ide_msk()
        )
    }
}
#[doc = "Message Buffer 0 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id0(pub u32);
impl Id0 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id0 {
    #[inline(always)]
    fn default() -> Id0 {
        Id0(0)
    }
}
impl core::fmt::Debug for Id0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id0")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id0 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 1 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id1(pub u32);
impl Id1 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id1 {
    #[inline(always)]
    fn default() -> Id1 {
        Id1(0)
    }
}
impl core::fmt::Debug for Id1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id1")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id1 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 10 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id10(pub u32);
impl Id10 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id10 {
    #[inline(always)]
    fn default() -> Id10 {
        Id10(0)
    }
}
impl core::fmt::Debug for Id10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id10")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id10 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 11 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id11(pub u32);
impl Id11 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id11 {
    #[inline(always)]
    fn default() -> Id11 {
        Id11(0)
    }
}
impl core::fmt::Debug for Id11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id11")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id11 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 12 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id12(pub u32);
impl Id12 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id12 {
    #[inline(always)]
    fn default() -> Id12 {
        Id12(0)
    }
}
impl core::fmt::Debug for Id12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id12")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id12 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 13 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id13(pub u32);
impl Id13 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id13 {
    #[inline(always)]
    fn default() -> Id13 {
        Id13(0)
    }
}
impl core::fmt::Debug for Id13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id13")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id13 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 14 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id14(pub u32);
impl Id14 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id14 {
    #[inline(always)]
    fn default() -> Id14 {
        Id14(0)
    }
}
impl core::fmt::Debug for Id14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id14")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id14 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 15 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id15(pub u32);
impl Id15 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id15 {
    #[inline(always)]
    fn default() -> Id15 {
        Id15(0)
    }
}
impl core::fmt::Debug for Id15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id15")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id15 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 16 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id16(pub u32);
impl Id16 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id16 {
    #[inline(always)]
    fn default() -> Id16 {
        Id16(0)
    }
}
impl core::fmt::Debug for Id16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id16")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id16 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id16 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 17 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id17(pub u32);
impl Id17 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id17 {
    #[inline(always)]
    fn default() -> Id17 {
        Id17(0)
    }
}
impl core::fmt::Debug for Id17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id17")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id17 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id17 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 18 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id18(pub u32);
impl Id18 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id18 {
    #[inline(always)]
    fn default() -> Id18 {
        Id18(0)
    }
}
impl core::fmt::Debug for Id18 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id18")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id18 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id18 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 19 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id19(pub u32);
impl Id19 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id19 {
    #[inline(always)]
    fn default() -> Id19 {
        Id19(0)
    }
}
impl core::fmt::Debug for Id19 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id19")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id19 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id19 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 2 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id2(pub u32);
impl Id2 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id2 {
    #[inline(always)]
    fn default() -> Id2 {
        Id2(0)
    }
}
impl core::fmt::Debug for Id2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id2")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id2 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 20 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id20(pub u32);
impl Id20 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id20 {
    #[inline(always)]
    fn default() -> Id20 {
        Id20(0)
    }
}
impl core::fmt::Debug for Id20 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id20")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id20 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id20 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 21 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id21(pub u32);
impl Id21 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id21 {
    #[inline(always)]
    fn default() -> Id21 {
        Id21(0)
    }
}
impl core::fmt::Debug for Id21 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id21")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id21 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id21 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 22 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id22(pub u32);
impl Id22 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id22 {
    #[inline(always)]
    fn default() -> Id22 {
        Id22(0)
    }
}
impl core::fmt::Debug for Id22 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id22")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id22 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id22 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 23 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id23(pub u32);
impl Id23 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id23 {
    #[inline(always)]
    fn default() -> Id23 {
        Id23(0)
    }
}
impl core::fmt::Debug for Id23 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id23")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id23 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id23 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 24 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id24(pub u32);
impl Id24 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id24 {
    #[inline(always)]
    fn default() -> Id24 {
        Id24(0)
    }
}
impl core::fmt::Debug for Id24 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id24")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id24 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id24 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 25 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id25(pub u32);
impl Id25 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id25 {
    #[inline(always)]
    fn default() -> Id25 {
        Id25(0)
    }
}
impl core::fmt::Debug for Id25 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id25")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id25 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id25 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 26 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id26(pub u32);
impl Id26 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id26 {
    #[inline(always)]
    fn default() -> Id26 {
        Id26(0)
    }
}
impl core::fmt::Debug for Id26 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id26")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id26 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id26 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 27 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id27(pub u32);
impl Id27 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id27 {
    #[inline(always)]
    fn default() -> Id27 {
        Id27(0)
    }
}
impl core::fmt::Debug for Id27 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id27")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id27 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id27 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 28 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id28(pub u32);
impl Id28 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id28 {
    #[inline(always)]
    fn default() -> Id28 {
        Id28(0)
    }
}
impl core::fmt::Debug for Id28 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id28")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id28 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id28 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 29 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id29(pub u32);
impl Id29 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id29 {
    #[inline(always)]
    fn default() -> Id29 {
        Id29(0)
    }
}
impl core::fmt::Debug for Id29 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id29")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id29 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id29 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 3 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id3(pub u32);
impl Id3 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id3 {
    #[inline(always)]
    fn default() -> Id3 {
        Id3(0)
    }
}
impl core::fmt::Debug for Id3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id3")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id3 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 30 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id30(pub u32);
impl Id30 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id30 {
    #[inline(always)]
    fn default() -> Id30 {
        Id30(0)
    }
}
impl core::fmt::Debug for Id30 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id30")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id30 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id30 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 31 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id31(pub u32);
impl Id31 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id31 {
    #[inline(always)]
    fn default() -> Id31 {
        Id31(0)
    }
}
impl core::fmt::Debug for Id31 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id31")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id31 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id31 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 4 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id4(pub u32);
impl Id4 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id4 {
    #[inline(always)]
    fn default() -> Id4 {
        Id4(0)
    }
}
impl core::fmt::Debug for Id4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id4")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id4 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 5 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id5(pub u32);
impl Id5 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id5 {
    #[inline(always)]
    fn default() -> Id5 {
        Id5(0)
    }
}
impl core::fmt::Debug for Id5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id5")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id5 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 6 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id6(pub u32);
impl Id6 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id6 {
    #[inline(always)]
    fn default() -> Id6 {
        Id6(0)
    }
}
impl core::fmt::Debug for Id6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id6")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id6 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 7 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id7(pub u32);
impl Id7 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id7 {
    #[inline(always)]
    fn default() -> Id7 {
        Id7(0)
    }
}
impl core::fmt::Debug for Id7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id7")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id7 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 8 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id8(pub u32);
impl Id8 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id8 {
    #[inline(always)]
    fn default() -> Id8 {
        Id8(0)
    }
}
impl core::fmt::Debug for Id8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id8")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id8 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 9 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id9(pub u32);
impl Id9 {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Id9 {
    #[inline(always)]
    fn default() -> Id9 {
        Id9(0)
    }
}
impl core::fmt::Debug for Id9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Id9")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Id9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Id9 {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Interrupt Flags 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Iflag1(pub u32);
impl Iflag1 {
    #[doc = "Buffer MB0 Interrupt or Clear Legacy FIFO bit"]
    #[must_use]
    #[inline(always)]
    pub const fn buf0i(&self) -> super::vals::Buf0i {
        let val = (self.0 >> 0usize) & 0x01;
        super::vals::Buf0i::from_bits(val as u8)
    }
    #[doc = "Buffer MB0 Interrupt or Clear Legacy FIFO bit"]
    #[inline(always)]
    pub const fn set_buf0i(&mut self, val: super::vals::Buf0i) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
    }
    #[doc = "Buffer MBi Interrupt or Reserved"]
    #[must_use]
    #[inline(always)]
    pub const fn buf4to1i(&self) -> u8 {
        let val = (self.0 >> 1usize) & 0x0f;
        val as u8
    }
    #[doc = "Buffer MBi Interrupt or Reserved"]
    #[inline(always)]
    pub const fn set_buf4to1i(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 1usize)) | (((val as u32) & 0x0f) << 1usize);
    }
    #[doc = "Buffer MB5 Interrupt or Frames available in Legacy RX FIFO"]
    #[must_use]
    #[inline(always)]
    pub const fn buf5i(&self) -> super::vals::Buf5i {
        let val = (self.0 >> 5usize) & 0x01;
        super::vals::Buf5i::from_bits(val as u8)
    }
    #[doc = "Buffer MB5 Interrupt or Frames available in Legacy RX FIFO"]
    #[inline(always)]
    pub const fn set_buf5i(&mut self, val: super::vals::Buf5i) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
    }
    #[doc = "Buffer MB6 Interrupt or Legacy RX FIFO Warning"]
    #[must_use]
    #[inline(always)]
    pub const fn buf6i(&self) -> super::vals::Buf6i {
        let val = (self.0 >> 6usize) & 0x01;
        super::vals::Buf6i::from_bits(val as u8)
    }
    #[doc = "Buffer MB6 Interrupt or Legacy RX FIFO Warning"]
    #[inline(always)]
    pub const fn set_buf6i(&mut self, val: super::vals::Buf6i) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
    }
    #[doc = "Buffer MB7 Interrupt or Legacy RX FIFO Overflow"]
    #[must_use]
    #[inline(always)]
    pub const fn buf7i(&self) -> super::vals::Buf7i {
        let val = (self.0 >> 7usize) & 0x01;
        super::vals::Buf7i::from_bits(val as u8)
    }
    #[doc = "Buffer MB7 Interrupt or Legacy RX FIFO Overflow"]
    #[inline(always)]
    pub const fn set_buf7i(&mut self, val: super::vals::Buf7i) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
    }
    #[doc = "Buffer MBi Interrupt"]
    #[must_use]
    #[inline(always)]
    pub const fn buf31to8i(&self) -> u32 {
        let val = (self.0 >> 8usize) & 0x00ff_ffff;
        val as u32
    }
    #[doc = "Buffer MBi Interrupt"]
    #[inline(always)]
    pub const fn set_buf31to8i(&mut self, val: u32) {
        self.0 = (self.0 & !(0x00ff_ffff << 8usize)) | (((val as u32) & 0x00ff_ffff) << 8usize);
    }
}
impl Default for Iflag1 {
    #[inline(always)]
    fn default() -> Iflag1 {
        Iflag1(0)
    }
}
impl core::fmt::Debug for Iflag1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iflag1")
            .field("buf0i", &self.buf0i())
            .field("buf4to1i", &self.buf4to1i())
            .field("buf5i", &self.buf5i())
            .field("buf6i", &self.buf6i())
            .field("buf7i", &self.buf7i())
            .field("buf31to8i", &self.buf31to8i())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Iflag1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Iflag1 {{ buf0i: {:?}, buf4to1i: {=u8:?}, buf5i: {:?}, buf6i: {:?}, buf7i: {:?}, buf31to8i: {=u32:?} }}",
            self.buf0i(),
            self.buf4to1i(),
            self.buf5i(),
            self.buf6i(),
            self.buf7i(),
            self.buf31to8i()
        )
    }
}
#[doc = "Interrupt Masks 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Imask1(pub u32);
impl Imask1 {
    #[doc = "Buffer MBi Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn buf31to0m(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "Buffer MBi Mask"]
    #[inline(always)]
    pub const fn set_buf31to0m(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Imask1 {
    #[inline(always)]
    fn default() -> Imask1 {
        Imask1(0)
    }
}
impl core::fmt::Debug for Imask1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Imask1")
            .field("buf31to0m", &self.buf31to0m())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Imask1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Imask1 {{ buf31to0m: {=u32:?} }}", self.buf31to0m())
    }
}
#[doc = "Message Buffer 0 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bCs(pub u32);
impl Mb016bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb016bCs {
    #[inline(always)]
    fn default() -> Mb016bCs {
        Mb016bCs(0)
    }
}
impl core::fmt::Debug for Mb016bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 0 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bId(pub u32);
impl Mb016bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb016bId {
    #[inline(always)]
    fn default() -> Mb016bId {
        Mb016bId(0)
    }
}
impl core::fmt::Debug for Mb016bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 0 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bWord0(pub u32);
impl Mb016bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb016bWord0 {
    #[inline(always)]
    fn default() -> Mb016bWord0 {
        Mb016bWord0(0)
    }
}
impl core::fmt::Debug for Mb016bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 0 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bWord1(pub u32);
impl Mb016bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb016bWord1 {
    #[inline(always)]
    fn default() -> Mb016bWord1 {
        Mb016bWord1(0)
    }
}
impl core::fmt::Debug for Mb016bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 0 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bWord2(pub u32);
impl Mb016bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb016bWord2 {
    #[inline(always)]
    fn default() -> Mb016bWord2 {
        Mb016bWord2(0)
    }
}
impl core::fmt::Debug for Mb016bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 0 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb016bWord3(pub u32);
impl Mb016bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb016bWord3 {
    #[inline(always)]
    fn default() -> Mb016bWord3 {
        Mb016bWord3(0)
    }
}
impl core::fmt::Debug for Mb016bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb016bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb016bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb016bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 0 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bCs(pub u32);
impl Mb032bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb032bCs {
    #[inline(always)]
    fn default() -> Mb032bCs {
        Mb032bCs(0)
    }
}
impl core::fmt::Debug for Mb032bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 0 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bId(pub u32);
impl Mb032bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb032bId {
    #[inline(always)]
    fn default() -> Mb032bId {
        Mb032bId(0)
    }
}
impl core::fmt::Debug for Mb032bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord0(pub u32);
impl Mb032bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord0 {
    #[inline(always)]
    fn default() -> Mb032bWord0 {
        Mb032bWord0(0)
    }
}
impl core::fmt::Debug for Mb032bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord1(pub u32);
impl Mb032bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord1 {
    #[inline(always)]
    fn default() -> Mb032bWord1 {
        Mb032bWord1(0)
    }
}
impl core::fmt::Debug for Mb032bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord2(pub u32);
impl Mb032bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord2 {
    #[inline(always)]
    fn default() -> Mb032bWord2 {
        Mb032bWord2(0)
    }
}
impl core::fmt::Debug for Mb032bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord3(pub u32);
impl Mb032bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord3 {
    #[inline(always)]
    fn default() -> Mb032bWord3 {
        Mb032bWord3(0)
    }
}
impl core::fmt::Debug for Mb032bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord4(pub u32);
impl Mb032bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord4 {
    #[inline(always)]
    fn default() -> Mb032bWord4 {
        Mb032bWord4(0)
    }
}
impl core::fmt::Debug for Mb032bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord5(pub u32);
impl Mb032bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord5 {
    #[inline(always)]
    fn default() -> Mb032bWord5 {
        Mb032bWord5(0)
    }
}
impl core::fmt::Debug for Mb032bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord6(pub u32);
impl Mb032bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord6 {
    #[inline(always)]
    fn default() -> Mb032bWord6 {
        Mb032bWord6(0)
    }
}
impl core::fmt::Debug for Mb032bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 0 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb032bWord7(pub u32);
impl Mb032bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb032bWord7 {
    #[inline(always)]
    fn default() -> Mb032bWord7 {
        Mb032bWord7(0)
    }
}
impl core::fmt::Debug for Mb032bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb032bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb032bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb032bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 0 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bCs(pub u32);
impl Mb064bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb064bCs {
    #[inline(always)]
    fn default() -> Mb064bCs {
        Mb064bCs(0)
    }
}
impl core::fmt::Debug for Mb064bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 0 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bId(pub u32);
impl Mb064bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb064bId {
    #[inline(always)]
    fn default() -> Mb064bId {
        Mb064bId(0)
    }
}
impl core::fmt::Debug for Mb064bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord0(pub u32);
impl Mb064bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord0 {
    #[inline(always)]
    fn default() -> Mb064bWord0 {
        Mb064bWord0(0)
    }
}
impl core::fmt::Debug for Mb064bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord1(pub u32);
impl Mb064bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord1 {
    #[inline(always)]
    fn default() -> Mb064bWord1 {
        Mb064bWord1(0)
    }
}
impl core::fmt::Debug for Mb064bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord10(pub u32);
impl Mb064bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord10 {
    #[inline(always)]
    fn default() -> Mb064bWord10 {
        Mb064bWord10(0)
    }
}
impl core::fmt::Debug for Mb064bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord11(pub u32);
impl Mb064bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord11 {
    #[inline(always)]
    fn default() -> Mb064bWord11 {
        Mb064bWord11(0)
    }
}
impl core::fmt::Debug for Mb064bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord12(pub u32);
impl Mb064bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord12 {
    #[inline(always)]
    fn default() -> Mb064bWord12 {
        Mb064bWord12(0)
    }
}
impl core::fmt::Debug for Mb064bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord13(pub u32);
impl Mb064bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord13 {
    #[inline(always)]
    fn default() -> Mb064bWord13 {
        Mb064bWord13(0)
    }
}
impl core::fmt::Debug for Mb064bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord14(pub u32);
impl Mb064bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord14 {
    #[inline(always)]
    fn default() -> Mb064bWord14 {
        Mb064bWord14(0)
    }
}
impl core::fmt::Debug for Mb064bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord15(pub u32);
impl Mb064bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord15 {
    #[inline(always)]
    fn default() -> Mb064bWord15 {
        Mb064bWord15(0)
    }
}
impl core::fmt::Debug for Mb064bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord2(pub u32);
impl Mb064bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord2 {
    #[inline(always)]
    fn default() -> Mb064bWord2 {
        Mb064bWord2(0)
    }
}
impl core::fmt::Debug for Mb064bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord3(pub u32);
impl Mb064bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord3 {
    #[inline(always)]
    fn default() -> Mb064bWord3 {
        Mb064bWord3(0)
    }
}
impl core::fmt::Debug for Mb064bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord4(pub u32);
impl Mb064bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord4 {
    #[inline(always)]
    fn default() -> Mb064bWord4 {
        Mb064bWord4(0)
    }
}
impl core::fmt::Debug for Mb064bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord5(pub u32);
impl Mb064bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord5 {
    #[inline(always)]
    fn default() -> Mb064bWord5 {
        Mb064bWord5(0)
    }
}
impl core::fmt::Debug for Mb064bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord6(pub u32);
impl Mb064bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord6 {
    #[inline(always)]
    fn default() -> Mb064bWord6 {
        Mb064bWord6(0)
    }
}
impl core::fmt::Debug for Mb064bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord7(pub u32);
impl Mb064bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord7 {
    #[inline(always)]
    fn default() -> Mb064bWord7 {
        Mb064bWord7(0)
    }
}
impl core::fmt::Debug for Mb064bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord8(pub u32);
impl Mb064bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord8 {
    #[inline(always)]
    fn default() -> Mb064bWord8 {
        Mb064bWord8(0)
    }
}
impl core::fmt::Debug for Mb064bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 0 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb064bWord9(pub u32);
impl Mb064bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb064bWord9 {
    #[inline(always)]
    fn default() -> Mb064bWord9 {
        Mb064bWord9(0)
    }
}
impl core::fmt::Debug for Mb064bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb064bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb064bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb064bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 0 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb08bCs(pub u32);
impl Mb08bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb08bCs {
    #[inline(always)]
    fn default() -> Mb08bCs {
        Mb08bCs(0)
    }
}
impl core::fmt::Debug for Mb08bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb08bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb08bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb08bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 0 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb08bId(pub u32);
impl Mb08bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb08bId {
    #[inline(always)]
    fn default() -> Mb08bId {
        Mb08bId(0)
    }
}
impl core::fmt::Debug for Mb08bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb08bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb08bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb08bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 0 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb08bWord0(pub u32);
impl Mb08bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb08bWord0 {
    #[inline(always)]
    fn default() -> Mb08bWord0 {
        Mb08bWord0(0)
    }
}
impl core::fmt::Debug for Mb08bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb08bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb08bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb08bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 0 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb08bWord1(pub u32);
impl Mb08bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb08bWord1 {
    #[inline(always)]
    fn default() -> Mb08bWord1 {
        Mb08bWord1(0)
    }
}
impl core::fmt::Debug for Mb08bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb08bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb08bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb08bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 10 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bCs(pub u32);
impl Mb1016bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1016bCs {
    #[inline(always)]
    fn default() -> Mb1016bCs {
        Mb1016bCs(0)
    }
}
impl core::fmt::Debug for Mb1016bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 10 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bId(pub u32);
impl Mb1016bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1016bId {
    #[inline(always)]
    fn default() -> Mb1016bId {
        Mb1016bId(0)
    }
}
impl core::fmt::Debug for Mb1016bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 10 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bWord0(pub u32);
impl Mb1016bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1016bWord0 {
    #[inline(always)]
    fn default() -> Mb1016bWord0 {
        Mb1016bWord0(0)
    }
}
impl core::fmt::Debug for Mb1016bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 10 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bWord1(pub u32);
impl Mb1016bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1016bWord1 {
    #[inline(always)]
    fn default() -> Mb1016bWord1 {
        Mb1016bWord1(0)
    }
}
impl core::fmt::Debug for Mb1016bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 10 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bWord2(pub u32);
impl Mb1016bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1016bWord2 {
    #[inline(always)]
    fn default() -> Mb1016bWord2 {
        Mb1016bWord2(0)
    }
}
impl core::fmt::Debug for Mb1016bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 10 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1016bWord3(pub u32);
impl Mb1016bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1016bWord3 {
    #[inline(always)]
    fn default() -> Mb1016bWord3 {
        Mb1016bWord3(0)
    }
}
impl core::fmt::Debug for Mb1016bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1016bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1016bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1016bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 10 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bCs(pub u32);
impl Mb1032bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1032bCs {
    #[inline(always)]
    fn default() -> Mb1032bCs {
        Mb1032bCs(0)
    }
}
impl core::fmt::Debug for Mb1032bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 10 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bId(pub u32);
impl Mb1032bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1032bId {
    #[inline(always)]
    fn default() -> Mb1032bId {
        Mb1032bId(0)
    }
}
impl core::fmt::Debug for Mb1032bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord0(pub u32);
impl Mb1032bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord0 {
    #[inline(always)]
    fn default() -> Mb1032bWord0 {
        Mb1032bWord0(0)
    }
}
impl core::fmt::Debug for Mb1032bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord1(pub u32);
impl Mb1032bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord1 {
    #[inline(always)]
    fn default() -> Mb1032bWord1 {
        Mb1032bWord1(0)
    }
}
impl core::fmt::Debug for Mb1032bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord2(pub u32);
impl Mb1032bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord2 {
    #[inline(always)]
    fn default() -> Mb1032bWord2 {
        Mb1032bWord2(0)
    }
}
impl core::fmt::Debug for Mb1032bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord3(pub u32);
impl Mb1032bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord3 {
    #[inline(always)]
    fn default() -> Mb1032bWord3 {
        Mb1032bWord3(0)
    }
}
impl core::fmt::Debug for Mb1032bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord4(pub u32);
impl Mb1032bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord4 {
    #[inline(always)]
    fn default() -> Mb1032bWord4 {
        Mb1032bWord4(0)
    }
}
impl core::fmt::Debug for Mb1032bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord5(pub u32);
impl Mb1032bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord5 {
    #[inline(always)]
    fn default() -> Mb1032bWord5 {
        Mb1032bWord5(0)
    }
}
impl core::fmt::Debug for Mb1032bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord6(pub u32);
impl Mb1032bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord6 {
    #[inline(always)]
    fn default() -> Mb1032bWord6 {
        Mb1032bWord6(0)
    }
}
impl core::fmt::Debug for Mb1032bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 10 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1032bWord7(pub u32);
impl Mb1032bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1032bWord7 {
    #[inline(always)]
    fn default() -> Mb1032bWord7 {
        Mb1032bWord7(0)
    }
}
impl core::fmt::Debug for Mb1032bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1032bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1032bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1032bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 10 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb108bCs(pub u32);
impl Mb108bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb108bCs {
    #[inline(always)]
    fn default() -> Mb108bCs {
        Mb108bCs(0)
    }
}
impl core::fmt::Debug for Mb108bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb108bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb108bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb108bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 10 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb108bId(pub u32);
impl Mb108bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb108bId {
    #[inline(always)]
    fn default() -> Mb108bId {
        Mb108bId(0)
    }
}
impl core::fmt::Debug for Mb108bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb108bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb108bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb108bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 10 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb108bWord0(pub u32);
impl Mb108bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb108bWord0 {
    #[inline(always)]
    fn default() -> Mb108bWord0 {
        Mb108bWord0(0)
    }
}
impl core::fmt::Debug for Mb108bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb108bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb108bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb108bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 10 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb108bWord1(pub u32);
impl Mb108bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb108bWord1 {
    #[inline(always)]
    fn default() -> Mb108bWord1 {
        Mb108bWord1(0)
    }
}
impl core::fmt::Debug for Mb108bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb108bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb108bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb108bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 11 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bCs(pub u32);
impl Mb1116bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1116bCs {
    #[inline(always)]
    fn default() -> Mb1116bCs {
        Mb1116bCs(0)
    }
}
impl core::fmt::Debug for Mb1116bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 11 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bId(pub u32);
impl Mb1116bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1116bId {
    #[inline(always)]
    fn default() -> Mb1116bId {
        Mb1116bId(0)
    }
}
impl core::fmt::Debug for Mb1116bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 11 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bWord0(pub u32);
impl Mb1116bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1116bWord0 {
    #[inline(always)]
    fn default() -> Mb1116bWord0 {
        Mb1116bWord0(0)
    }
}
impl core::fmt::Debug for Mb1116bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 11 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bWord1(pub u32);
impl Mb1116bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1116bWord1 {
    #[inline(always)]
    fn default() -> Mb1116bWord1 {
        Mb1116bWord1(0)
    }
}
impl core::fmt::Debug for Mb1116bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 11 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bWord2(pub u32);
impl Mb1116bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1116bWord2 {
    #[inline(always)]
    fn default() -> Mb1116bWord2 {
        Mb1116bWord2(0)
    }
}
impl core::fmt::Debug for Mb1116bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 11 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1116bWord3(pub u32);
impl Mb1116bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1116bWord3 {
    #[inline(always)]
    fn default() -> Mb1116bWord3 {
        Mb1116bWord3(0)
    }
}
impl core::fmt::Debug for Mb1116bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1116bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1116bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1116bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 11 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bCs(pub u32);
impl Mb1132bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1132bCs {
    #[inline(always)]
    fn default() -> Mb1132bCs {
        Mb1132bCs(0)
    }
}
impl core::fmt::Debug for Mb1132bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 11 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bId(pub u32);
impl Mb1132bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1132bId {
    #[inline(always)]
    fn default() -> Mb1132bId {
        Mb1132bId(0)
    }
}
impl core::fmt::Debug for Mb1132bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord0(pub u32);
impl Mb1132bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord0 {
    #[inline(always)]
    fn default() -> Mb1132bWord0 {
        Mb1132bWord0(0)
    }
}
impl core::fmt::Debug for Mb1132bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord1(pub u32);
impl Mb1132bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord1 {
    #[inline(always)]
    fn default() -> Mb1132bWord1 {
        Mb1132bWord1(0)
    }
}
impl core::fmt::Debug for Mb1132bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord2(pub u32);
impl Mb1132bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord2 {
    #[inline(always)]
    fn default() -> Mb1132bWord2 {
        Mb1132bWord2(0)
    }
}
impl core::fmt::Debug for Mb1132bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord3(pub u32);
impl Mb1132bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord3 {
    #[inline(always)]
    fn default() -> Mb1132bWord3 {
        Mb1132bWord3(0)
    }
}
impl core::fmt::Debug for Mb1132bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord4(pub u32);
impl Mb1132bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord4 {
    #[inline(always)]
    fn default() -> Mb1132bWord4 {
        Mb1132bWord4(0)
    }
}
impl core::fmt::Debug for Mb1132bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord5(pub u32);
impl Mb1132bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord5 {
    #[inline(always)]
    fn default() -> Mb1132bWord5 {
        Mb1132bWord5(0)
    }
}
impl core::fmt::Debug for Mb1132bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord6(pub u32);
impl Mb1132bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord6 {
    #[inline(always)]
    fn default() -> Mb1132bWord6 {
        Mb1132bWord6(0)
    }
}
impl core::fmt::Debug for Mb1132bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 11 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1132bWord7(pub u32);
impl Mb1132bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1132bWord7 {
    #[inline(always)]
    fn default() -> Mb1132bWord7 {
        Mb1132bWord7(0)
    }
}
impl core::fmt::Debug for Mb1132bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1132bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1132bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1132bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 1 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bCs(pub u32);
impl Mb116bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb116bCs {
    #[inline(always)]
    fn default() -> Mb116bCs {
        Mb116bCs(0)
    }
}
impl core::fmt::Debug for Mb116bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 1 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bId(pub u32);
impl Mb116bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb116bId {
    #[inline(always)]
    fn default() -> Mb116bId {
        Mb116bId(0)
    }
}
impl core::fmt::Debug for Mb116bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 1 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bWord0(pub u32);
impl Mb116bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb116bWord0 {
    #[inline(always)]
    fn default() -> Mb116bWord0 {
        Mb116bWord0(0)
    }
}
impl core::fmt::Debug for Mb116bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 1 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bWord1(pub u32);
impl Mb116bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb116bWord1 {
    #[inline(always)]
    fn default() -> Mb116bWord1 {
        Mb116bWord1(0)
    }
}
impl core::fmt::Debug for Mb116bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 1 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bWord2(pub u32);
impl Mb116bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb116bWord2 {
    #[inline(always)]
    fn default() -> Mb116bWord2 {
        Mb116bWord2(0)
    }
}
impl core::fmt::Debug for Mb116bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 1 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb116bWord3(pub u32);
impl Mb116bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb116bWord3 {
    #[inline(always)]
    fn default() -> Mb116bWord3 {
        Mb116bWord3(0)
    }
}
impl core::fmt::Debug for Mb116bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb116bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb116bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb116bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 11 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb118bCs(pub u32);
impl Mb118bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb118bCs {
    #[inline(always)]
    fn default() -> Mb118bCs {
        Mb118bCs(0)
    }
}
impl core::fmt::Debug for Mb118bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb118bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb118bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb118bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 11 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb118bId(pub u32);
impl Mb118bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb118bId {
    #[inline(always)]
    fn default() -> Mb118bId {
        Mb118bId(0)
    }
}
impl core::fmt::Debug for Mb118bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb118bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb118bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb118bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 11 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb118bWord0(pub u32);
impl Mb118bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb118bWord0 {
    #[inline(always)]
    fn default() -> Mb118bWord0 {
        Mb118bWord0(0)
    }
}
impl core::fmt::Debug for Mb118bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb118bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb118bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb118bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 11 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb118bWord1(pub u32);
impl Mb118bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb118bWord1 {
    #[inline(always)]
    fn default() -> Mb118bWord1 {
        Mb118bWord1(0)
    }
}
impl core::fmt::Debug for Mb118bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb118bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb118bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb118bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 12 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bCs(pub u32);
impl Mb1216bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1216bCs {
    #[inline(always)]
    fn default() -> Mb1216bCs {
        Mb1216bCs(0)
    }
}
impl core::fmt::Debug for Mb1216bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 12 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bId(pub u32);
impl Mb1216bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1216bId {
    #[inline(always)]
    fn default() -> Mb1216bId {
        Mb1216bId(0)
    }
}
impl core::fmt::Debug for Mb1216bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 12 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bWord0(pub u32);
impl Mb1216bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1216bWord0 {
    #[inline(always)]
    fn default() -> Mb1216bWord0 {
        Mb1216bWord0(0)
    }
}
impl core::fmt::Debug for Mb1216bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 12 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bWord1(pub u32);
impl Mb1216bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1216bWord1 {
    #[inline(always)]
    fn default() -> Mb1216bWord1 {
        Mb1216bWord1(0)
    }
}
impl core::fmt::Debug for Mb1216bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 12 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bWord2(pub u32);
impl Mb1216bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1216bWord2 {
    #[inline(always)]
    fn default() -> Mb1216bWord2 {
        Mb1216bWord2(0)
    }
}
impl core::fmt::Debug for Mb1216bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 12 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1216bWord3(pub u32);
impl Mb1216bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1216bWord3 {
    #[inline(always)]
    fn default() -> Mb1216bWord3 {
        Mb1216bWord3(0)
    }
}
impl core::fmt::Debug for Mb1216bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1216bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1216bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1216bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 12 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb128bCs(pub u32);
impl Mb128bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb128bCs {
    #[inline(always)]
    fn default() -> Mb128bCs {
        Mb128bCs(0)
    }
}
impl core::fmt::Debug for Mb128bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb128bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb128bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb128bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 12 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb128bId(pub u32);
impl Mb128bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb128bId {
    #[inline(always)]
    fn default() -> Mb128bId {
        Mb128bId(0)
    }
}
impl core::fmt::Debug for Mb128bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb128bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb128bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb128bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 12 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb128bWord0(pub u32);
impl Mb128bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb128bWord0 {
    #[inline(always)]
    fn default() -> Mb128bWord0 {
        Mb128bWord0(0)
    }
}
impl core::fmt::Debug for Mb128bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb128bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb128bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb128bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 12 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb128bWord1(pub u32);
impl Mb128bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb128bWord1 {
    #[inline(always)]
    fn default() -> Mb128bWord1 {
        Mb128bWord1(0)
    }
}
impl core::fmt::Debug for Mb128bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb128bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb128bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb128bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 13 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bCs(pub u32);
impl Mb1316bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1316bCs {
    #[inline(always)]
    fn default() -> Mb1316bCs {
        Mb1316bCs(0)
    }
}
impl core::fmt::Debug for Mb1316bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 13 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bId(pub u32);
impl Mb1316bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1316bId {
    #[inline(always)]
    fn default() -> Mb1316bId {
        Mb1316bId(0)
    }
}
impl core::fmt::Debug for Mb1316bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 13 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bWord0(pub u32);
impl Mb1316bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1316bWord0 {
    #[inline(always)]
    fn default() -> Mb1316bWord0 {
        Mb1316bWord0(0)
    }
}
impl core::fmt::Debug for Mb1316bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 13 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bWord1(pub u32);
impl Mb1316bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1316bWord1 {
    #[inline(always)]
    fn default() -> Mb1316bWord1 {
        Mb1316bWord1(0)
    }
}
impl core::fmt::Debug for Mb1316bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 13 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bWord2(pub u32);
impl Mb1316bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1316bWord2 {
    #[inline(always)]
    fn default() -> Mb1316bWord2 {
        Mb1316bWord2(0)
    }
}
impl core::fmt::Debug for Mb1316bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 13 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1316bWord3(pub u32);
impl Mb1316bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1316bWord3 {
    #[inline(always)]
    fn default() -> Mb1316bWord3 {
        Mb1316bWord3(0)
    }
}
impl core::fmt::Debug for Mb1316bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1316bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1316bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1316bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 1 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bCs(pub u32);
impl Mb132bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb132bCs {
    #[inline(always)]
    fn default() -> Mb132bCs {
        Mb132bCs(0)
    }
}
impl core::fmt::Debug for Mb132bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 1 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bId(pub u32);
impl Mb132bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb132bId {
    #[inline(always)]
    fn default() -> Mb132bId {
        Mb132bId(0)
    }
}
impl core::fmt::Debug for Mb132bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord0(pub u32);
impl Mb132bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord0 {
    #[inline(always)]
    fn default() -> Mb132bWord0 {
        Mb132bWord0(0)
    }
}
impl core::fmt::Debug for Mb132bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord1(pub u32);
impl Mb132bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord1 {
    #[inline(always)]
    fn default() -> Mb132bWord1 {
        Mb132bWord1(0)
    }
}
impl core::fmt::Debug for Mb132bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord2(pub u32);
impl Mb132bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord2 {
    #[inline(always)]
    fn default() -> Mb132bWord2 {
        Mb132bWord2(0)
    }
}
impl core::fmt::Debug for Mb132bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord3(pub u32);
impl Mb132bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord3 {
    #[inline(always)]
    fn default() -> Mb132bWord3 {
        Mb132bWord3(0)
    }
}
impl core::fmt::Debug for Mb132bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord4(pub u32);
impl Mb132bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord4 {
    #[inline(always)]
    fn default() -> Mb132bWord4 {
        Mb132bWord4(0)
    }
}
impl core::fmt::Debug for Mb132bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord5(pub u32);
impl Mb132bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord5 {
    #[inline(always)]
    fn default() -> Mb132bWord5 {
        Mb132bWord5(0)
    }
}
impl core::fmt::Debug for Mb132bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord6(pub u32);
impl Mb132bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord6 {
    #[inline(always)]
    fn default() -> Mb132bWord6 {
        Mb132bWord6(0)
    }
}
impl core::fmt::Debug for Mb132bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 1 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb132bWord7(pub u32);
impl Mb132bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb132bWord7 {
    #[inline(always)]
    fn default() -> Mb132bWord7 {
        Mb132bWord7(0)
    }
}
impl core::fmt::Debug for Mb132bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb132bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb132bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb132bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 13 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb138bCs(pub u32);
impl Mb138bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb138bCs {
    #[inline(always)]
    fn default() -> Mb138bCs {
        Mb138bCs(0)
    }
}
impl core::fmt::Debug for Mb138bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb138bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb138bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb138bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 13 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb138bId(pub u32);
impl Mb138bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb138bId {
    #[inline(always)]
    fn default() -> Mb138bId {
        Mb138bId(0)
    }
}
impl core::fmt::Debug for Mb138bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb138bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb138bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb138bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 13 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb138bWord0(pub u32);
impl Mb138bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb138bWord0 {
    #[inline(always)]
    fn default() -> Mb138bWord0 {
        Mb138bWord0(0)
    }
}
impl core::fmt::Debug for Mb138bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb138bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb138bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb138bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 13 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb138bWord1(pub u32);
impl Mb138bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb138bWord1 {
    #[inline(always)]
    fn default() -> Mb138bWord1 {
        Mb138bWord1(0)
    }
}
impl core::fmt::Debug for Mb138bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb138bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb138bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb138bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 14 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bCs(pub u32);
impl Mb1416bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1416bCs {
    #[inline(always)]
    fn default() -> Mb1416bCs {
        Mb1416bCs(0)
    }
}
impl core::fmt::Debug for Mb1416bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 14 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bId(pub u32);
impl Mb1416bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1416bId {
    #[inline(always)]
    fn default() -> Mb1416bId {
        Mb1416bId(0)
    }
}
impl core::fmt::Debug for Mb1416bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 14 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bWord0(pub u32);
impl Mb1416bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1416bWord0 {
    #[inline(always)]
    fn default() -> Mb1416bWord0 {
        Mb1416bWord0(0)
    }
}
impl core::fmt::Debug for Mb1416bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 14 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bWord1(pub u32);
impl Mb1416bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1416bWord1 {
    #[inline(always)]
    fn default() -> Mb1416bWord1 {
        Mb1416bWord1(0)
    }
}
impl core::fmt::Debug for Mb1416bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 14 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bWord2(pub u32);
impl Mb1416bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1416bWord2 {
    #[inline(always)]
    fn default() -> Mb1416bWord2 {
        Mb1416bWord2(0)
    }
}
impl core::fmt::Debug for Mb1416bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 14 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1416bWord3(pub u32);
impl Mb1416bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1416bWord3 {
    #[inline(always)]
    fn default() -> Mb1416bWord3 {
        Mb1416bWord3(0)
    }
}
impl core::fmt::Debug for Mb1416bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1416bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1416bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1416bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 14 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb148bCs(pub u32);
impl Mb148bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb148bCs {
    #[inline(always)]
    fn default() -> Mb148bCs {
        Mb148bCs(0)
    }
}
impl core::fmt::Debug for Mb148bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb148bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb148bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb148bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 14 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb148bId(pub u32);
impl Mb148bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb148bId {
    #[inline(always)]
    fn default() -> Mb148bId {
        Mb148bId(0)
    }
}
impl core::fmt::Debug for Mb148bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb148bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb148bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb148bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 14 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb148bWord0(pub u32);
impl Mb148bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb148bWord0 {
    #[inline(always)]
    fn default() -> Mb148bWord0 {
        Mb148bWord0(0)
    }
}
impl core::fmt::Debug for Mb148bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb148bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb148bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb148bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 14 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb148bWord1(pub u32);
impl Mb148bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb148bWord1 {
    #[inline(always)]
    fn default() -> Mb148bWord1 {
        Mb148bWord1(0)
    }
}
impl core::fmt::Debug for Mb148bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb148bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb148bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb148bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 15 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bCs(pub u32);
impl Mb1516bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1516bCs {
    #[inline(always)]
    fn default() -> Mb1516bCs {
        Mb1516bCs(0)
    }
}
impl core::fmt::Debug for Mb1516bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 15 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bId(pub u32);
impl Mb1516bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1516bId {
    #[inline(always)]
    fn default() -> Mb1516bId {
        Mb1516bId(0)
    }
}
impl core::fmt::Debug for Mb1516bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 15 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bWord0(pub u32);
impl Mb1516bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1516bWord0 {
    #[inline(always)]
    fn default() -> Mb1516bWord0 {
        Mb1516bWord0(0)
    }
}
impl core::fmt::Debug for Mb1516bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 15 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bWord1(pub u32);
impl Mb1516bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1516bWord1 {
    #[inline(always)]
    fn default() -> Mb1516bWord1 {
        Mb1516bWord1(0)
    }
}
impl core::fmt::Debug for Mb1516bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 15 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bWord2(pub u32);
impl Mb1516bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1516bWord2 {
    #[inline(always)]
    fn default() -> Mb1516bWord2 {
        Mb1516bWord2(0)
    }
}
impl core::fmt::Debug for Mb1516bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 15 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1516bWord3(pub u32);
impl Mb1516bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1516bWord3 {
    #[inline(always)]
    fn default() -> Mb1516bWord3 {
        Mb1516bWord3(0)
    }
}
impl core::fmt::Debug for Mb1516bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1516bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1516bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1516bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 15 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb158bCs(pub u32);
impl Mb158bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb158bCs {
    #[inline(always)]
    fn default() -> Mb158bCs {
        Mb158bCs(0)
    }
}
impl core::fmt::Debug for Mb158bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb158bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb158bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb158bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 15 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb158bId(pub u32);
impl Mb158bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb158bId {
    #[inline(always)]
    fn default() -> Mb158bId {
        Mb158bId(0)
    }
}
impl core::fmt::Debug for Mb158bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb158bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb158bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb158bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 15 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb158bWord0(pub u32);
impl Mb158bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb158bWord0 {
    #[inline(always)]
    fn default() -> Mb158bWord0 {
        Mb158bWord0(0)
    }
}
impl core::fmt::Debug for Mb158bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb158bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb158bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb158bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 15 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb158bWord1(pub u32);
impl Mb158bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb158bWord1 {
    #[inline(always)]
    fn default() -> Mb158bWord1 {
        Mb158bWord1(0)
    }
}
impl core::fmt::Debug for Mb158bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb158bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb158bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb158bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 16 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bCs(pub u32);
impl Mb1616bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1616bCs {
    #[inline(always)]
    fn default() -> Mb1616bCs {
        Mb1616bCs(0)
    }
}
impl core::fmt::Debug for Mb1616bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 16 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bId(pub u32);
impl Mb1616bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1616bId {
    #[inline(always)]
    fn default() -> Mb1616bId {
        Mb1616bId(0)
    }
}
impl core::fmt::Debug for Mb1616bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 16 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bWord0(pub u32);
impl Mb1616bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1616bWord0 {
    #[inline(always)]
    fn default() -> Mb1616bWord0 {
        Mb1616bWord0(0)
    }
}
impl core::fmt::Debug for Mb1616bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 16 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bWord1(pub u32);
impl Mb1616bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1616bWord1 {
    #[inline(always)]
    fn default() -> Mb1616bWord1 {
        Mb1616bWord1(0)
    }
}
impl core::fmt::Debug for Mb1616bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 16 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bWord2(pub u32);
impl Mb1616bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1616bWord2 {
    #[inline(always)]
    fn default() -> Mb1616bWord2 {
        Mb1616bWord2(0)
    }
}
impl core::fmt::Debug for Mb1616bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 16 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1616bWord3(pub u32);
impl Mb1616bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1616bWord3 {
    #[inline(always)]
    fn default() -> Mb1616bWord3 {
        Mb1616bWord3(0)
    }
}
impl core::fmt::Debug for Mb1616bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1616bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1616bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1616bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 1 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bCs(pub u32);
impl Mb164bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb164bCs {
    #[inline(always)]
    fn default() -> Mb164bCs {
        Mb164bCs(0)
    }
}
impl core::fmt::Debug for Mb164bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 1 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bId(pub u32);
impl Mb164bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb164bId {
    #[inline(always)]
    fn default() -> Mb164bId {
        Mb164bId(0)
    }
}
impl core::fmt::Debug for Mb164bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord0(pub u32);
impl Mb164bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord0 {
    #[inline(always)]
    fn default() -> Mb164bWord0 {
        Mb164bWord0(0)
    }
}
impl core::fmt::Debug for Mb164bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord1(pub u32);
impl Mb164bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord1 {
    #[inline(always)]
    fn default() -> Mb164bWord1 {
        Mb164bWord1(0)
    }
}
impl core::fmt::Debug for Mb164bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord10(pub u32);
impl Mb164bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord10 {
    #[inline(always)]
    fn default() -> Mb164bWord10 {
        Mb164bWord10(0)
    }
}
impl core::fmt::Debug for Mb164bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord11(pub u32);
impl Mb164bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord11 {
    #[inline(always)]
    fn default() -> Mb164bWord11 {
        Mb164bWord11(0)
    }
}
impl core::fmt::Debug for Mb164bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord12(pub u32);
impl Mb164bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord12 {
    #[inline(always)]
    fn default() -> Mb164bWord12 {
        Mb164bWord12(0)
    }
}
impl core::fmt::Debug for Mb164bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord13(pub u32);
impl Mb164bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord13 {
    #[inline(always)]
    fn default() -> Mb164bWord13 {
        Mb164bWord13(0)
    }
}
impl core::fmt::Debug for Mb164bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord14(pub u32);
impl Mb164bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord14 {
    #[inline(always)]
    fn default() -> Mb164bWord14 {
        Mb164bWord14(0)
    }
}
impl core::fmt::Debug for Mb164bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord15(pub u32);
impl Mb164bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord15 {
    #[inline(always)]
    fn default() -> Mb164bWord15 {
        Mb164bWord15(0)
    }
}
impl core::fmt::Debug for Mb164bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord2(pub u32);
impl Mb164bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord2 {
    #[inline(always)]
    fn default() -> Mb164bWord2 {
        Mb164bWord2(0)
    }
}
impl core::fmt::Debug for Mb164bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord3(pub u32);
impl Mb164bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord3 {
    #[inline(always)]
    fn default() -> Mb164bWord3 {
        Mb164bWord3(0)
    }
}
impl core::fmt::Debug for Mb164bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord4(pub u32);
impl Mb164bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord4 {
    #[inline(always)]
    fn default() -> Mb164bWord4 {
        Mb164bWord4(0)
    }
}
impl core::fmt::Debug for Mb164bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord5(pub u32);
impl Mb164bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord5 {
    #[inline(always)]
    fn default() -> Mb164bWord5 {
        Mb164bWord5(0)
    }
}
impl core::fmt::Debug for Mb164bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord6(pub u32);
impl Mb164bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord6 {
    #[inline(always)]
    fn default() -> Mb164bWord6 {
        Mb164bWord6(0)
    }
}
impl core::fmt::Debug for Mb164bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord7(pub u32);
impl Mb164bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord7 {
    #[inline(always)]
    fn default() -> Mb164bWord7 {
        Mb164bWord7(0)
    }
}
impl core::fmt::Debug for Mb164bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord8(pub u32);
impl Mb164bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord8 {
    #[inline(always)]
    fn default() -> Mb164bWord8 {
        Mb164bWord8(0)
    }
}
impl core::fmt::Debug for Mb164bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 1 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb164bWord9(pub u32);
impl Mb164bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb164bWord9 {
    #[inline(always)]
    fn default() -> Mb164bWord9 {
        Mb164bWord9(0)
    }
}
impl core::fmt::Debug for Mb164bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb164bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb164bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb164bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 16 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb168bCs(pub u32);
impl Mb168bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb168bCs {
    #[inline(always)]
    fn default() -> Mb168bCs {
        Mb168bCs(0)
    }
}
impl core::fmt::Debug for Mb168bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb168bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb168bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb168bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 16 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb168bId(pub u32);
impl Mb168bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb168bId {
    #[inline(always)]
    fn default() -> Mb168bId {
        Mb168bId(0)
    }
}
impl core::fmt::Debug for Mb168bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb168bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb168bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb168bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 16 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb168bWord0(pub u32);
impl Mb168bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb168bWord0 {
    #[inline(always)]
    fn default() -> Mb168bWord0 {
        Mb168bWord0(0)
    }
}
impl core::fmt::Debug for Mb168bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb168bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb168bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb168bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 16 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb168bWord1(pub u32);
impl Mb168bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb168bWord1 {
    #[inline(always)]
    fn default() -> Mb168bWord1 {
        Mb168bWord1(0)
    }
}
impl core::fmt::Debug for Mb168bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb168bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb168bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb168bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 17 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bCs(pub u32);
impl Mb1716bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1716bCs {
    #[inline(always)]
    fn default() -> Mb1716bCs {
        Mb1716bCs(0)
    }
}
impl core::fmt::Debug for Mb1716bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 17 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bId(pub u32);
impl Mb1716bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1716bId {
    #[inline(always)]
    fn default() -> Mb1716bId {
        Mb1716bId(0)
    }
}
impl core::fmt::Debug for Mb1716bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 17 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bWord0(pub u32);
impl Mb1716bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1716bWord0 {
    #[inline(always)]
    fn default() -> Mb1716bWord0 {
        Mb1716bWord0(0)
    }
}
impl core::fmt::Debug for Mb1716bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 17 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bWord1(pub u32);
impl Mb1716bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1716bWord1 {
    #[inline(always)]
    fn default() -> Mb1716bWord1 {
        Mb1716bWord1(0)
    }
}
impl core::fmt::Debug for Mb1716bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 17 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bWord2(pub u32);
impl Mb1716bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1716bWord2 {
    #[inline(always)]
    fn default() -> Mb1716bWord2 {
        Mb1716bWord2(0)
    }
}
impl core::fmt::Debug for Mb1716bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 17 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1716bWord3(pub u32);
impl Mb1716bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1716bWord3 {
    #[inline(always)]
    fn default() -> Mb1716bWord3 {
        Mb1716bWord3(0)
    }
}
impl core::fmt::Debug for Mb1716bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1716bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1716bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1716bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 17 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb178bCs(pub u32);
impl Mb178bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb178bCs {
    #[inline(always)]
    fn default() -> Mb178bCs {
        Mb178bCs(0)
    }
}
impl core::fmt::Debug for Mb178bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb178bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb178bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb178bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 17 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb178bId(pub u32);
impl Mb178bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb178bId {
    #[inline(always)]
    fn default() -> Mb178bId {
        Mb178bId(0)
    }
}
impl core::fmt::Debug for Mb178bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb178bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb178bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb178bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 17 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb178bWord0(pub u32);
impl Mb178bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb178bWord0 {
    #[inline(always)]
    fn default() -> Mb178bWord0 {
        Mb178bWord0(0)
    }
}
impl core::fmt::Debug for Mb178bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb178bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb178bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb178bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 17 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb178bWord1(pub u32);
impl Mb178bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb178bWord1 {
    #[inline(always)]
    fn default() -> Mb178bWord1 {
        Mb178bWord1(0)
    }
}
impl core::fmt::Debug for Mb178bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb178bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb178bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb178bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 18 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bCs(pub u32);
impl Mb1816bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1816bCs {
    #[inline(always)]
    fn default() -> Mb1816bCs {
        Mb1816bCs(0)
    }
}
impl core::fmt::Debug for Mb1816bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 18 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bId(pub u32);
impl Mb1816bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1816bId {
    #[inline(always)]
    fn default() -> Mb1816bId {
        Mb1816bId(0)
    }
}
impl core::fmt::Debug for Mb1816bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 18 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bWord0(pub u32);
impl Mb1816bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1816bWord0 {
    #[inline(always)]
    fn default() -> Mb1816bWord0 {
        Mb1816bWord0(0)
    }
}
impl core::fmt::Debug for Mb1816bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 18 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bWord1(pub u32);
impl Mb1816bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1816bWord1 {
    #[inline(always)]
    fn default() -> Mb1816bWord1 {
        Mb1816bWord1(0)
    }
}
impl core::fmt::Debug for Mb1816bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 18 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bWord2(pub u32);
impl Mb1816bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1816bWord2 {
    #[inline(always)]
    fn default() -> Mb1816bWord2 {
        Mb1816bWord2(0)
    }
}
impl core::fmt::Debug for Mb1816bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 18 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1816bWord3(pub u32);
impl Mb1816bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1816bWord3 {
    #[inline(always)]
    fn default() -> Mb1816bWord3 {
        Mb1816bWord3(0)
    }
}
impl core::fmt::Debug for Mb1816bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1816bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1816bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1816bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 18 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb188bCs(pub u32);
impl Mb188bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb188bCs {
    #[inline(always)]
    fn default() -> Mb188bCs {
        Mb188bCs(0)
    }
}
impl core::fmt::Debug for Mb188bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb188bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb188bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb188bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 18 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb188bId(pub u32);
impl Mb188bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb188bId {
    #[inline(always)]
    fn default() -> Mb188bId {
        Mb188bId(0)
    }
}
impl core::fmt::Debug for Mb188bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb188bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb188bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb188bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 18 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb188bWord0(pub u32);
impl Mb188bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb188bWord0 {
    #[inline(always)]
    fn default() -> Mb188bWord0 {
        Mb188bWord0(0)
    }
}
impl core::fmt::Debug for Mb188bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb188bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb188bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb188bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 18 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb188bWord1(pub u32);
impl Mb188bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb188bWord1 {
    #[inline(always)]
    fn default() -> Mb188bWord1 {
        Mb188bWord1(0)
    }
}
impl core::fmt::Debug for Mb188bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb188bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb188bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb188bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 1 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb18bCs(pub u32);
impl Mb18bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb18bCs {
    #[inline(always)]
    fn default() -> Mb18bCs {
        Mb18bCs(0)
    }
}
impl core::fmt::Debug for Mb18bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb18bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb18bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb18bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 1 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb18bId(pub u32);
impl Mb18bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb18bId {
    #[inline(always)]
    fn default() -> Mb18bId {
        Mb18bId(0)
    }
}
impl core::fmt::Debug for Mb18bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb18bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb18bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb18bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 1 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb18bWord0(pub u32);
impl Mb18bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb18bWord0 {
    #[inline(always)]
    fn default() -> Mb18bWord0 {
        Mb18bWord0(0)
    }
}
impl core::fmt::Debug for Mb18bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb18bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb18bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb18bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 1 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb18bWord1(pub u32);
impl Mb18bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb18bWord1 {
    #[inline(always)]
    fn default() -> Mb18bWord1 {
        Mb18bWord1(0)
    }
}
impl core::fmt::Debug for Mb18bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb18bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb18bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb18bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 19 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bCs(pub u32);
impl Mb1916bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb1916bCs {
    #[inline(always)]
    fn default() -> Mb1916bCs {
        Mb1916bCs(0)
    }
}
impl core::fmt::Debug for Mb1916bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 19 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bId(pub u32);
impl Mb1916bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb1916bId {
    #[inline(always)]
    fn default() -> Mb1916bId {
        Mb1916bId(0)
    }
}
impl core::fmt::Debug for Mb1916bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 19 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bWord0(pub u32);
impl Mb1916bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1916bWord0 {
    #[inline(always)]
    fn default() -> Mb1916bWord0 {
        Mb1916bWord0(0)
    }
}
impl core::fmt::Debug for Mb1916bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 19 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bWord1(pub u32);
impl Mb1916bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1916bWord1 {
    #[inline(always)]
    fn default() -> Mb1916bWord1 {
        Mb1916bWord1(0)
    }
}
impl core::fmt::Debug for Mb1916bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 19 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bWord2(pub u32);
impl Mb1916bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1916bWord2 {
    #[inline(always)]
    fn default() -> Mb1916bWord2 {
        Mb1916bWord2(0)
    }
}
impl core::fmt::Debug for Mb1916bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 19 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb1916bWord3(pub u32);
impl Mb1916bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb1916bWord3 {
    #[inline(always)]
    fn default() -> Mb1916bWord3 {
        Mb1916bWord3(0)
    }
}
impl core::fmt::Debug for Mb1916bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb1916bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb1916bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb1916bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 19 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb198bCs(pub u32);
impl Mb198bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb198bCs {
    #[inline(always)]
    fn default() -> Mb198bCs {
        Mb198bCs(0)
    }
}
impl core::fmt::Debug for Mb198bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb198bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb198bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb198bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 19 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb198bId(pub u32);
impl Mb198bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb198bId {
    #[inline(always)]
    fn default() -> Mb198bId {
        Mb198bId(0)
    }
}
impl core::fmt::Debug for Mb198bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb198bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb198bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb198bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 19 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb198bWord0(pub u32);
impl Mb198bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb198bWord0 {
    #[inline(always)]
    fn default() -> Mb198bWord0 {
        Mb198bWord0(0)
    }
}
impl core::fmt::Debug for Mb198bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb198bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb198bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb198bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 19 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb198bWord1(pub u32);
impl Mb198bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb198bWord1 {
    #[inline(always)]
    fn default() -> Mb198bWord1 {
        Mb198bWord1(0)
    }
}
impl core::fmt::Debug for Mb198bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb198bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb198bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb198bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 20 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bCs(pub u32);
impl Mb2016bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb2016bCs {
    #[inline(always)]
    fn default() -> Mb2016bCs {
        Mb2016bCs(0)
    }
}
impl core::fmt::Debug for Mb2016bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 20 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bId(pub u32);
impl Mb2016bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb2016bId {
    #[inline(always)]
    fn default() -> Mb2016bId {
        Mb2016bId(0)
    }
}
impl core::fmt::Debug for Mb2016bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 20 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bWord0(pub u32);
impl Mb2016bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb2016bWord0 {
    #[inline(always)]
    fn default() -> Mb2016bWord0 {
        Mb2016bWord0(0)
    }
}
impl core::fmt::Debug for Mb2016bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 20 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bWord1(pub u32);
impl Mb2016bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb2016bWord1 {
    #[inline(always)]
    fn default() -> Mb2016bWord1 {
        Mb2016bWord1(0)
    }
}
impl core::fmt::Debug for Mb2016bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 20 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bWord2(pub u32);
impl Mb2016bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb2016bWord2 {
    #[inline(always)]
    fn default() -> Mb2016bWord2 {
        Mb2016bWord2(0)
    }
}
impl core::fmt::Debug for Mb2016bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 20 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb2016bWord3(pub u32);
impl Mb2016bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb2016bWord3 {
    #[inline(always)]
    fn default() -> Mb2016bWord3 {
        Mb2016bWord3(0)
    }
}
impl core::fmt::Debug for Mb2016bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb2016bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb2016bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb2016bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 20 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb208bCs(pub u32);
impl Mb208bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb208bCs {
    #[inline(always)]
    fn default() -> Mb208bCs {
        Mb208bCs(0)
    }
}
impl core::fmt::Debug for Mb208bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb208bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb208bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb208bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 20 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb208bId(pub u32);
impl Mb208bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb208bId {
    #[inline(always)]
    fn default() -> Mb208bId {
        Mb208bId(0)
    }
}
impl core::fmt::Debug for Mb208bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb208bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb208bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb208bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 20 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb208bWord0(pub u32);
impl Mb208bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb208bWord0 {
    #[inline(always)]
    fn default() -> Mb208bWord0 {
        Mb208bWord0(0)
    }
}
impl core::fmt::Debug for Mb208bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb208bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb208bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb208bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 20 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb208bWord1(pub u32);
impl Mb208bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb208bWord1 {
    #[inline(always)]
    fn default() -> Mb208bWord1 {
        Mb208bWord1(0)
    }
}
impl core::fmt::Debug for Mb208bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb208bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb208bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb208bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bCs(pub u32);
impl Mb216bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb216bCs {
    #[inline(always)]
    fn default() -> Mb216bCs {
        Mb216bCs(0)
    }
}
impl core::fmt::Debug for Mb216bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 2 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bId(pub u32);
impl Mb216bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb216bId {
    #[inline(always)]
    fn default() -> Mb216bId {
        Mb216bId(0)
    }
}
impl core::fmt::Debug for Mb216bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 2 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bWord0(pub u32);
impl Mb216bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb216bWord0 {
    #[inline(always)]
    fn default() -> Mb216bWord0 {
        Mb216bWord0(0)
    }
}
impl core::fmt::Debug for Mb216bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 2 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bWord1(pub u32);
impl Mb216bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb216bWord1 {
    #[inline(always)]
    fn default() -> Mb216bWord1 {
        Mb216bWord1(0)
    }
}
impl core::fmt::Debug for Mb216bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bWord2(pub u32);
impl Mb216bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb216bWord2 {
    #[inline(always)]
    fn default() -> Mb216bWord2 {
        Mb216bWord2(0)
    }
}
impl core::fmt::Debug for Mb216bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 2 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb216bWord3(pub u32);
impl Mb216bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb216bWord3 {
    #[inline(always)]
    fn default() -> Mb216bWord3 {
        Mb216bWord3(0)
    }
}
impl core::fmt::Debug for Mb216bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb216bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb216bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb216bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 21 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb218bCs(pub u32);
impl Mb218bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb218bCs {
    #[inline(always)]
    fn default() -> Mb218bCs {
        Mb218bCs(0)
    }
}
impl core::fmt::Debug for Mb218bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb218bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb218bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb218bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 21 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb218bId(pub u32);
impl Mb218bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb218bId {
    #[inline(always)]
    fn default() -> Mb218bId {
        Mb218bId(0)
    }
}
impl core::fmt::Debug for Mb218bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb218bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb218bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb218bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 21 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb218bWord0(pub u32);
impl Mb218bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb218bWord0 {
    #[inline(always)]
    fn default() -> Mb218bWord0 {
        Mb218bWord0(0)
    }
}
impl core::fmt::Debug for Mb218bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb218bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb218bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb218bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 21 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb218bWord1(pub u32);
impl Mb218bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb218bWord1 {
    #[inline(always)]
    fn default() -> Mb218bWord1 {
        Mb218bWord1(0)
    }
}
impl core::fmt::Debug for Mb218bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb218bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb218bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb218bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 22 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb228bCs(pub u32);
impl Mb228bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb228bCs {
    #[inline(always)]
    fn default() -> Mb228bCs {
        Mb228bCs(0)
    }
}
impl core::fmt::Debug for Mb228bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb228bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb228bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb228bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 22 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb228bId(pub u32);
impl Mb228bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb228bId {
    #[inline(always)]
    fn default() -> Mb228bId {
        Mb228bId(0)
    }
}
impl core::fmt::Debug for Mb228bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb228bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb228bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb228bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 22 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb228bWord0(pub u32);
impl Mb228bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb228bWord0 {
    #[inline(always)]
    fn default() -> Mb228bWord0 {
        Mb228bWord0(0)
    }
}
impl core::fmt::Debug for Mb228bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb228bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb228bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb228bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 22 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb228bWord1(pub u32);
impl Mb228bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb228bWord1 {
    #[inline(always)]
    fn default() -> Mb228bWord1 {
        Mb228bWord1(0)
    }
}
impl core::fmt::Debug for Mb228bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb228bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb228bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb228bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bCs(pub u32);
impl Mb232bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb232bCs {
    #[inline(always)]
    fn default() -> Mb232bCs {
        Mb232bCs(0)
    }
}
impl core::fmt::Debug for Mb232bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 2 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bId(pub u32);
impl Mb232bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb232bId {
    #[inline(always)]
    fn default() -> Mb232bId {
        Mb232bId(0)
    }
}
impl core::fmt::Debug for Mb232bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord0(pub u32);
impl Mb232bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord0 {
    #[inline(always)]
    fn default() -> Mb232bWord0 {
        Mb232bWord0(0)
    }
}
impl core::fmt::Debug for Mb232bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord1(pub u32);
impl Mb232bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord1 {
    #[inline(always)]
    fn default() -> Mb232bWord1 {
        Mb232bWord1(0)
    }
}
impl core::fmt::Debug for Mb232bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord2(pub u32);
impl Mb232bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord2 {
    #[inline(always)]
    fn default() -> Mb232bWord2 {
        Mb232bWord2(0)
    }
}
impl core::fmt::Debug for Mb232bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord3(pub u32);
impl Mb232bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord3 {
    #[inline(always)]
    fn default() -> Mb232bWord3 {
        Mb232bWord3(0)
    }
}
impl core::fmt::Debug for Mb232bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord4(pub u32);
impl Mb232bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord4 {
    #[inline(always)]
    fn default() -> Mb232bWord4 {
        Mb232bWord4(0)
    }
}
impl core::fmt::Debug for Mb232bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord5(pub u32);
impl Mb232bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord5 {
    #[inline(always)]
    fn default() -> Mb232bWord5 {
        Mb232bWord5(0)
    }
}
impl core::fmt::Debug for Mb232bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord6(pub u32);
impl Mb232bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord6 {
    #[inline(always)]
    fn default() -> Mb232bWord6 {
        Mb232bWord6(0)
    }
}
impl core::fmt::Debug for Mb232bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 2 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb232bWord7(pub u32);
impl Mb232bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb232bWord7 {
    #[inline(always)]
    fn default() -> Mb232bWord7 {
        Mb232bWord7(0)
    }
}
impl core::fmt::Debug for Mb232bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb232bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb232bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb232bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 23 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb238bCs(pub u32);
impl Mb238bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb238bCs {
    #[inline(always)]
    fn default() -> Mb238bCs {
        Mb238bCs(0)
    }
}
impl core::fmt::Debug for Mb238bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb238bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb238bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb238bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 23 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb238bId(pub u32);
impl Mb238bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb238bId {
    #[inline(always)]
    fn default() -> Mb238bId {
        Mb238bId(0)
    }
}
impl core::fmt::Debug for Mb238bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb238bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb238bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb238bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 23 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb238bWord0(pub u32);
impl Mb238bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb238bWord0 {
    #[inline(always)]
    fn default() -> Mb238bWord0 {
        Mb238bWord0(0)
    }
}
impl core::fmt::Debug for Mb238bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb238bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb238bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb238bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 23 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb238bWord1(pub u32);
impl Mb238bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb238bWord1 {
    #[inline(always)]
    fn default() -> Mb238bWord1 {
        Mb238bWord1(0)
    }
}
impl core::fmt::Debug for Mb238bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb238bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb238bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb238bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 24 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb248bCs(pub u32);
impl Mb248bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb248bCs {
    #[inline(always)]
    fn default() -> Mb248bCs {
        Mb248bCs(0)
    }
}
impl core::fmt::Debug for Mb248bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb248bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb248bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb248bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 24 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb248bId(pub u32);
impl Mb248bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb248bId {
    #[inline(always)]
    fn default() -> Mb248bId {
        Mb248bId(0)
    }
}
impl core::fmt::Debug for Mb248bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb248bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb248bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb248bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 24 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb248bWord0(pub u32);
impl Mb248bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb248bWord0 {
    #[inline(always)]
    fn default() -> Mb248bWord0 {
        Mb248bWord0(0)
    }
}
impl core::fmt::Debug for Mb248bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb248bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb248bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb248bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 24 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb248bWord1(pub u32);
impl Mb248bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb248bWord1 {
    #[inline(always)]
    fn default() -> Mb248bWord1 {
        Mb248bWord1(0)
    }
}
impl core::fmt::Debug for Mb248bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb248bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb248bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb248bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 25 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb258bCs(pub u32);
impl Mb258bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb258bCs {
    #[inline(always)]
    fn default() -> Mb258bCs {
        Mb258bCs(0)
    }
}
impl core::fmt::Debug for Mb258bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb258bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb258bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb258bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 25 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb258bId(pub u32);
impl Mb258bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb258bId {
    #[inline(always)]
    fn default() -> Mb258bId {
        Mb258bId(0)
    }
}
impl core::fmt::Debug for Mb258bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb258bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb258bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb258bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 25 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb258bWord0(pub u32);
impl Mb258bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb258bWord0 {
    #[inline(always)]
    fn default() -> Mb258bWord0 {
        Mb258bWord0(0)
    }
}
impl core::fmt::Debug for Mb258bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb258bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb258bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb258bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 25 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb258bWord1(pub u32);
impl Mb258bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb258bWord1 {
    #[inline(always)]
    fn default() -> Mb258bWord1 {
        Mb258bWord1(0)
    }
}
impl core::fmt::Debug for Mb258bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb258bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb258bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb258bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bCs(pub u32);
impl Mb264bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb264bCs {
    #[inline(always)]
    fn default() -> Mb264bCs {
        Mb264bCs(0)
    }
}
impl core::fmt::Debug for Mb264bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 2 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bId(pub u32);
impl Mb264bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb264bId {
    #[inline(always)]
    fn default() -> Mb264bId {
        Mb264bId(0)
    }
}
impl core::fmt::Debug for Mb264bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord0(pub u32);
impl Mb264bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord0 {
    #[inline(always)]
    fn default() -> Mb264bWord0 {
        Mb264bWord0(0)
    }
}
impl core::fmt::Debug for Mb264bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord1(pub u32);
impl Mb264bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord1 {
    #[inline(always)]
    fn default() -> Mb264bWord1 {
        Mb264bWord1(0)
    }
}
impl core::fmt::Debug for Mb264bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord10(pub u32);
impl Mb264bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord10 {
    #[inline(always)]
    fn default() -> Mb264bWord10 {
        Mb264bWord10(0)
    }
}
impl core::fmt::Debug for Mb264bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord11(pub u32);
impl Mb264bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord11 {
    #[inline(always)]
    fn default() -> Mb264bWord11 {
        Mb264bWord11(0)
    }
}
impl core::fmt::Debug for Mb264bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord12(pub u32);
impl Mb264bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord12 {
    #[inline(always)]
    fn default() -> Mb264bWord12 {
        Mb264bWord12(0)
    }
}
impl core::fmt::Debug for Mb264bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord13(pub u32);
impl Mb264bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord13 {
    #[inline(always)]
    fn default() -> Mb264bWord13 {
        Mb264bWord13(0)
    }
}
impl core::fmt::Debug for Mb264bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord14(pub u32);
impl Mb264bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord14 {
    #[inline(always)]
    fn default() -> Mb264bWord14 {
        Mb264bWord14(0)
    }
}
impl core::fmt::Debug for Mb264bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord15(pub u32);
impl Mb264bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord15 {
    #[inline(always)]
    fn default() -> Mb264bWord15 {
        Mb264bWord15(0)
    }
}
impl core::fmt::Debug for Mb264bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord2(pub u32);
impl Mb264bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord2 {
    #[inline(always)]
    fn default() -> Mb264bWord2 {
        Mb264bWord2(0)
    }
}
impl core::fmt::Debug for Mb264bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord3(pub u32);
impl Mb264bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord3 {
    #[inline(always)]
    fn default() -> Mb264bWord3 {
        Mb264bWord3(0)
    }
}
impl core::fmt::Debug for Mb264bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord4(pub u32);
impl Mb264bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord4 {
    #[inline(always)]
    fn default() -> Mb264bWord4 {
        Mb264bWord4(0)
    }
}
impl core::fmt::Debug for Mb264bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord5(pub u32);
impl Mb264bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord5 {
    #[inline(always)]
    fn default() -> Mb264bWord5 {
        Mb264bWord5(0)
    }
}
impl core::fmt::Debug for Mb264bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord6(pub u32);
impl Mb264bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord6 {
    #[inline(always)]
    fn default() -> Mb264bWord6 {
        Mb264bWord6(0)
    }
}
impl core::fmt::Debug for Mb264bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord7(pub u32);
impl Mb264bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord7 {
    #[inline(always)]
    fn default() -> Mb264bWord7 {
        Mb264bWord7(0)
    }
}
impl core::fmt::Debug for Mb264bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord8(pub u32);
impl Mb264bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord8 {
    #[inline(always)]
    fn default() -> Mb264bWord8 {
        Mb264bWord8(0)
    }
}
impl core::fmt::Debug for Mb264bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 2 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb264bWord9(pub u32);
impl Mb264bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb264bWord9 {
    #[inline(always)]
    fn default() -> Mb264bWord9 {
        Mb264bWord9(0)
    }
}
impl core::fmt::Debug for Mb264bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb264bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb264bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb264bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 26 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb268bCs(pub u32);
impl Mb268bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb268bCs {
    #[inline(always)]
    fn default() -> Mb268bCs {
        Mb268bCs(0)
    }
}
impl core::fmt::Debug for Mb268bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb268bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb268bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb268bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 26 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb268bId(pub u32);
impl Mb268bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb268bId {
    #[inline(always)]
    fn default() -> Mb268bId {
        Mb268bId(0)
    }
}
impl core::fmt::Debug for Mb268bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb268bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb268bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb268bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 26 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb268bWord0(pub u32);
impl Mb268bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb268bWord0 {
    #[inline(always)]
    fn default() -> Mb268bWord0 {
        Mb268bWord0(0)
    }
}
impl core::fmt::Debug for Mb268bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb268bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb268bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb268bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 26 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb268bWord1(pub u32);
impl Mb268bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb268bWord1 {
    #[inline(always)]
    fn default() -> Mb268bWord1 {
        Mb268bWord1(0)
    }
}
impl core::fmt::Debug for Mb268bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb268bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb268bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb268bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 27 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb278bCs(pub u32);
impl Mb278bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb278bCs {
    #[inline(always)]
    fn default() -> Mb278bCs {
        Mb278bCs(0)
    }
}
impl core::fmt::Debug for Mb278bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb278bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb278bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb278bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 27 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb278bId(pub u32);
impl Mb278bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb278bId {
    #[inline(always)]
    fn default() -> Mb278bId {
        Mb278bId(0)
    }
}
impl core::fmt::Debug for Mb278bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb278bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb278bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb278bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 27 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb278bWord0(pub u32);
impl Mb278bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb278bWord0 {
    #[inline(always)]
    fn default() -> Mb278bWord0 {
        Mb278bWord0(0)
    }
}
impl core::fmt::Debug for Mb278bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb278bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb278bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb278bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 27 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb278bWord1(pub u32);
impl Mb278bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb278bWord1 {
    #[inline(always)]
    fn default() -> Mb278bWord1 {
        Mb278bWord1(0)
    }
}
impl core::fmt::Debug for Mb278bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb278bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb278bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb278bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 28 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb288bCs(pub u32);
impl Mb288bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb288bCs {
    #[inline(always)]
    fn default() -> Mb288bCs {
        Mb288bCs(0)
    }
}
impl core::fmt::Debug for Mb288bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb288bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb288bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb288bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 28 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb288bId(pub u32);
impl Mb288bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb288bId {
    #[inline(always)]
    fn default() -> Mb288bId {
        Mb288bId(0)
    }
}
impl core::fmt::Debug for Mb288bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb288bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb288bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb288bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 28 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb288bWord0(pub u32);
impl Mb288bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb288bWord0 {
    #[inline(always)]
    fn default() -> Mb288bWord0 {
        Mb288bWord0(0)
    }
}
impl core::fmt::Debug for Mb288bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb288bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb288bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb288bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 28 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb288bWord1(pub u32);
impl Mb288bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb288bWord1 {
    #[inline(always)]
    fn default() -> Mb288bWord1 {
        Mb288bWord1(0)
    }
}
impl core::fmt::Debug for Mb288bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb288bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb288bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb288bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb28bCs(pub u32);
impl Mb28bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb28bCs {
    #[inline(always)]
    fn default() -> Mb28bCs {
        Mb28bCs(0)
    }
}
impl core::fmt::Debug for Mb28bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb28bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb28bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb28bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 2 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb28bId(pub u32);
impl Mb28bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb28bId {
    #[inline(always)]
    fn default() -> Mb28bId {
        Mb28bId(0)
    }
}
impl core::fmt::Debug for Mb28bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb28bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb28bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb28bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 2 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb28bWord0(pub u32);
impl Mb28bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb28bWord0 {
    #[inline(always)]
    fn default() -> Mb28bWord0 {
        Mb28bWord0(0)
    }
}
impl core::fmt::Debug for Mb28bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb28bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb28bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb28bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 2 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb28bWord1(pub u32);
impl Mb28bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb28bWord1 {
    #[inline(always)]
    fn default() -> Mb28bWord1 {
        Mb28bWord1(0)
    }
}
impl core::fmt::Debug for Mb28bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb28bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb28bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb28bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 29 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb298bCs(pub u32);
impl Mb298bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb298bCs {
    #[inline(always)]
    fn default() -> Mb298bCs {
        Mb298bCs(0)
    }
}
impl core::fmt::Debug for Mb298bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb298bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb298bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb298bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 29 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb298bId(pub u32);
impl Mb298bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb298bId {
    #[inline(always)]
    fn default() -> Mb298bId {
        Mb298bId(0)
    }
}
impl core::fmt::Debug for Mb298bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb298bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb298bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb298bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 29 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb298bWord0(pub u32);
impl Mb298bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb298bWord0 {
    #[inline(always)]
    fn default() -> Mb298bWord0 {
        Mb298bWord0(0)
    }
}
impl core::fmt::Debug for Mb298bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb298bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb298bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb298bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 29 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb298bWord1(pub u32);
impl Mb298bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb298bWord1 {
    #[inline(always)]
    fn default() -> Mb298bWord1 {
        Mb298bWord1(0)
    }
}
impl core::fmt::Debug for Mb298bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb298bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb298bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb298bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 30 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb308bCs(pub u32);
impl Mb308bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb308bCs {
    #[inline(always)]
    fn default() -> Mb308bCs {
        Mb308bCs(0)
    }
}
impl core::fmt::Debug for Mb308bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb308bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb308bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb308bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 30 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb308bId(pub u32);
impl Mb308bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb308bId {
    #[inline(always)]
    fn default() -> Mb308bId {
        Mb308bId(0)
    }
}
impl core::fmt::Debug for Mb308bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb308bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb308bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb308bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 30 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb308bWord0(pub u32);
impl Mb308bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb308bWord0 {
    #[inline(always)]
    fn default() -> Mb308bWord0 {
        Mb308bWord0(0)
    }
}
impl core::fmt::Debug for Mb308bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb308bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb308bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb308bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 30 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb308bWord1(pub u32);
impl Mb308bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb308bWord1 {
    #[inline(always)]
    fn default() -> Mb308bWord1 {
        Mb308bWord1(0)
    }
}
impl core::fmt::Debug for Mb308bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb308bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb308bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb308bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bCs(pub u32);
impl Mb316bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb316bCs {
    #[inline(always)]
    fn default() -> Mb316bCs {
        Mb316bCs(0)
    }
}
impl core::fmt::Debug for Mb316bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 3 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bId(pub u32);
impl Mb316bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb316bId {
    #[inline(always)]
    fn default() -> Mb316bId {
        Mb316bId(0)
    }
}
impl core::fmt::Debug for Mb316bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 3 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bWord0(pub u32);
impl Mb316bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb316bWord0 {
    #[inline(always)]
    fn default() -> Mb316bWord0 {
        Mb316bWord0(0)
    }
}
impl core::fmt::Debug for Mb316bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 3 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bWord1(pub u32);
impl Mb316bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb316bWord1 {
    #[inline(always)]
    fn default() -> Mb316bWord1 {
        Mb316bWord1(0)
    }
}
impl core::fmt::Debug for Mb316bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bWord2(pub u32);
impl Mb316bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb316bWord2 {
    #[inline(always)]
    fn default() -> Mb316bWord2 {
        Mb316bWord2(0)
    }
}
impl core::fmt::Debug for Mb316bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 3 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb316bWord3(pub u32);
impl Mb316bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb316bWord3 {
    #[inline(always)]
    fn default() -> Mb316bWord3 {
        Mb316bWord3(0)
    }
}
impl core::fmt::Debug for Mb316bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb316bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb316bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb316bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 31 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb318bCs(pub u32);
impl Mb318bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb318bCs {
    #[inline(always)]
    fn default() -> Mb318bCs {
        Mb318bCs(0)
    }
}
impl core::fmt::Debug for Mb318bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb318bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb318bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb318bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 31 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb318bId(pub u32);
impl Mb318bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb318bId {
    #[inline(always)]
    fn default() -> Mb318bId {
        Mb318bId(0)
    }
}
impl core::fmt::Debug for Mb318bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb318bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb318bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb318bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 31 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb318bWord0(pub u32);
impl Mb318bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb318bWord0 {
    #[inline(always)]
    fn default() -> Mb318bWord0 {
        Mb318bWord0(0)
    }
}
impl core::fmt::Debug for Mb318bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb318bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb318bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb318bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 31 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb318bWord1(pub u32);
impl Mb318bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb318bWord1 {
    #[inline(always)]
    fn default() -> Mb318bWord1 {
        Mb318bWord1(0)
    }
}
impl core::fmt::Debug for Mb318bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb318bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb318bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb318bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bCs(pub u32);
impl Mb332bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb332bCs {
    #[inline(always)]
    fn default() -> Mb332bCs {
        Mb332bCs(0)
    }
}
impl core::fmt::Debug for Mb332bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 3 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bId(pub u32);
impl Mb332bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb332bId {
    #[inline(always)]
    fn default() -> Mb332bId {
        Mb332bId(0)
    }
}
impl core::fmt::Debug for Mb332bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord0(pub u32);
impl Mb332bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord0 {
    #[inline(always)]
    fn default() -> Mb332bWord0 {
        Mb332bWord0(0)
    }
}
impl core::fmt::Debug for Mb332bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord1(pub u32);
impl Mb332bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord1 {
    #[inline(always)]
    fn default() -> Mb332bWord1 {
        Mb332bWord1(0)
    }
}
impl core::fmt::Debug for Mb332bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord2(pub u32);
impl Mb332bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord2 {
    #[inline(always)]
    fn default() -> Mb332bWord2 {
        Mb332bWord2(0)
    }
}
impl core::fmt::Debug for Mb332bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord3(pub u32);
impl Mb332bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord3 {
    #[inline(always)]
    fn default() -> Mb332bWord3 {
        Mb332bWord3(0)
    }
}
impl core::fmt::Debug for Mb332bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord4(pub u32);
impl Mb332bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord4 {
    #[inline(always)]
    fn default() -> Mb332bWord4 {
        Mb332bWord4(0)
    }
}
impl core::fmt::Debug for Mb332bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord5(pub u32);
impl Mb332bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord5 {
    #[inline(always)]
    fn default() -> Mb332bWord5 {
        Mb332bWord5(0)
    }
}
impl core::fmt::Debug for Mb332bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord6(pub u32);
impl Mb332bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord6 {
    #[inline(always)]
    fn default() -> Mb332bWord6 {
        Mb332bWord6(0)
    }
}
impl core::fmt::Debug for Mb332bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 3 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb332bWord7(pub u32);
impl Mb332bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb332bWord7 {
    #[inline(always)]
    fn default() -> Mb332bWord7 {
        Mb332bWord7(0)
    }
}
impl core::fmt::Debug for Mb332bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb332bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb332bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb332bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 3 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bCs(pub u32);
impl Mb364bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb364bCs {
    #[inline(always)]
    fn default() -> Mb364bCs {
        Mb364bCs(0)
    }
}
impl core::fmt::Debug for Mb364bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 3 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bId(pub u32);
impl Mb364bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb364bId {
    #[inline(always)]
    fn default() -> Mb364bId {
        Mb364bId(0)
    }
}
impl core::fmt::Debug for Mb364bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord0(pub u32);
impl Mb364bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord0 {
    #[inline(always)]
    fn default() -> Mb364bWord0 {
        Mb364bWord0(0)
    }
}
impl core::fmt::Debug for Mb364bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord1(pub u32);
impl Mb364bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord1 {
    #[inline(always)]
    fn default() -> Mb364bWord1 {
        Mb364bWord1(0)
    }
}
impl core::fmt::Debug for Mb364bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord10(pub u32);
impl Mb364bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord10 {
    #[inline(always)]
    fn default() -> Mb364bWord10 {
        Mb364bWord10(0)
    }
}
impl core::fmt::Debug for Mb364bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord11(pub u32);
impl Mb364bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord11 {
    #[inline(always)]
    fn default() -> Mb364bWord11 {
        Mb364bWord11(0)
    }
}
impl core::fmt::Debug for Mb364bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord12(pub u32);
impl Mb364bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord12 {
    #[inline(always)]
    fn default() -> Mb364bWord12 {
        Mb364bWord12(0)
    }
}
impl core::fmt::Debug for Mb364bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord13(pub u32);
impl Mb364bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord13 {
    #[inline(always)]
    fn default() -> Mb364bWord13 {
        Mb364bWord13(0)
    }
}
impl core::fmt::Debug for Mb364bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord14(pub u32);
impl Mb364bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord14 {
    #[inline(always)]
    fn default() -> Mb364bWord14 {
        Mb364bWord14(0)
    }
}
impl core::fmt::Debug for Mb364bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord15(pub u32);
impl Mb364bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord15 {
    #[inline(always)]
    fn default() -> Mb364bWord15 {
        Mb364bWord15(0)
    }
}
impl core::fmt::Debug for Mb364bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord2(pub u32);
impl Mb364bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord2 {
    #[inline(always)]
    fn default() -> Mb364bWord2 {
        Mb364bWord2(0)
    }
}
impl core::fmt::Debug for Mb364bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord3(pub u32);
impl Mb364bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord3 {
    #[inline(always)]
    fn default() -> Mb364bWord3 {
        Mb364bWord3(0)
    }
}
impl core::fmt::Debug for Mb364bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord4(pub u32);
impl Mb364bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord4 {
    #[inline(always)]
    fn default() -> Mb364bWord4 {
        Mb364bWord4(0)
    }
}
impl core::fmt::Debug for Mb364bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord5(pub u32);
impl Mb364bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord5 {
    #[inline(always)]
    fn default() -> Mb364bWord5 {
        Mb364bWord5(0)
    }
}
impl core::fmt::Debug for Mb364bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord6(pub u32);
impl Mb364bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord6 {
    #[inline(always)]
    fn default() -> Mb364bWord6 {
        Mb364bWord6(0)
    }
}
impl core::fmt::Debug for Mb364bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord7(pub u32);
impl Mb364bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord7 {
    #[inline(always)]
    fn default() -> Mb364bWord7 {
        Mb364bWord7(0)
    }
}
impl core::fmt::Debug for Mb364bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord8(pub u32);
impl Mb364bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord8 {
    #[inline(always)]
    fn default() -> Mb364bWord8 {
        Mb364bWord8(0)
    }
}
impl core::fmt::Debug for Mb364bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 3 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb364bWord9(pub u32);
impl Mb364bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb364bWord9 {
    #[inline(always)]
    fn default() -> Mb364bWord9 {
        Mb364bWord9(0)
    }
}
impl core::fmt::Debug for Mb364bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb364bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb364bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb364bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 3 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb38bCs(pub u32);
impl Mb38bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb38bCs {
    #[inline(always)]
    fn default() -> Mb38bCs {
        Mb38bCs(0)
    }
}
impl core::fmt::Debug for Mb38bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb38bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb38bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb38bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 3 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb38bId(pub u32);
impl Mb38bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb38bId {
    #[inline(always)]
    fn default() -> Mb38bId {
        Mb38bId(0)
    }
}
impl core::fmt::Debug for Mb38bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb38bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb38bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb38bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 3 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb38bWord0(pub u32);
impl Mb38bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb38bWord0 {
    #[inline(always)]
    fn default() -> Mb38bWord0 {
        Mb38bWord0(0)
    }
}
impl core::fmt::Debug for Mb38bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb38bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb38bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb38bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 3 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb38bWord1(pub u32);
impl Mb38bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb38bWord1 {
    #[inline(always)]
    fn default() -> Mb38bWord1 {
        Mb38bWord1(0)
    }
}
impl core::fmt::Debug for Mb38bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb38bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb38bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb38bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 4 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bCs(pub u32);
impl Mb416bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb416bCs {
    #[inline(always)]
    fn default() -> Mb416bCs {
        Mb416bCs(0)
    }
}
impl core::fmt::Debug for Mb416bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 4 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bId(pub u32);
impl Mb416bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb416bId {
    #[inline(always)]
    fn default() -> Mb416bId {
        Mb416bId(0)
    }
}
impl core::fmt::Debug for Mb416bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 4 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bWord0(pub u32);
impl Mb416bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb416bWord0 {
    #[inline(always)]
    fn default() -> Mb416bWord0 {
        Mb416bWord0(0)
    }
}
impl core::fmt::Debug for Mb416bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 4 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bWord1(pub u32);
impl Mb416bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb416bWord1 {
    #[inline(always)]
    fn default() -> Mb416bWord1 {
        Mb416bWord1(0)
    }
}
impl core::fmt::Debug for Mb416bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 4 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bWord2(pub u32);
impl Mb416bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb416bWord2 {
    #[inline(always)]
    fn default() -> Mb416bWord2 {
        Mb416bWord2(0)
    }
}
impl core::fmt::Debug for Mb416bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 4 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb416bWord3(pub u32);
impl Mb416bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb416bWord3 {
    #[inline(always)]
    fn default() -> Mb416bWord3 {
        Mb416bWord3(0)
    }
}
impl core::fmt::Debug for Mb416bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb416bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb416bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb416bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 4 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bCs(pub u32);
impl Mb432bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb432bCs {
    #[inline(always)]
    fn default() -> Mb432bCs {
        Mb432bCs(0)
    }
}
impl core::fmt::Debug for Mb432bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 4 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bId(pub u32);
impl Mb432bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb432bId {
    #[inline(always)]
    fn default() -> Mb432bId {
        Mb432bId(0)
    }
}
impl core::fmt::Debug for Mb432bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord0(pub u32);
impl Mb432bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord0 {
    #[inline(always)]
    fn default() -> Mb432bWord0 {
        Mb432bWord0(0)
    }
}
impl core::fmt::Debug for Mb432bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord1(pub u32);
impl Mb432bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord1 {
    #[inline(always)]
    fn default() -> Mb432bWord1 {
        Mb432bWord1(0)
    }
}
impl core::fmt::Debug for Mb432bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord2(pub u32);
impl Mb432bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord2 {
    #[inline(always)]
    fn default() -> Mb432bWord2 {
        Mb432bWord2(0)
    }
}
impl core::fmt::Debug for Mb432bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord3(pub u32);
impl Mb432bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord3 {
    #[inline(always)]
    fn default() -> Mb432bWord3 {
        Mb432bWord3(0)
    }
}
impl core::fmt::Debug for Mb432bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord4(pub u32);
impl Mb432bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord4 {
    #[inline(always)]
    fn default() -> Mb432bWord4 {
        Mb432bWord4(0)
    }
}
impl core::fmt::Debug for Mb432bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord5(pub u32);
impl Mb432bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord5 {
    #[inline(always)]
    fn default() -> Mb432bWord5 {
        Mb432bWord5(0)
    }
}
impl core::fmt::Debug for Mb432bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord6(pub u32);
impl Mb432bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord6 {
    #[inline(always)]
    fn default() -> Mb432bWord6 {
        Mb432bWord6(0)
    }
}
impl core::fmt::Debug for Mb432bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 4 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb432bWord7(pub u32);
impl Mb432bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb432bWord7 {
    #[inline(always)]
    fn default() -> Mb432bWord7 {
        Mb432bWord7(0)
    }
}
impl core::fmt::Debug for Mb432bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb432bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb432bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb432bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 4 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bCs(pub u32);
impl Mb464bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb464bCs {
    #[inline(always)]
    fn default() -> Mb464bCs {
        Mb464bCs(0)
    }
}
impl core::fmt::Debug for Mb464bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 4 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bId(pub u32);
impl Mb464bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb464bId {
    #[inline(always)]
    fn default() -> Mb464bId {
        Mb464bId(0)
    }
}
impl core::fmt::Debug for Mb464bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord0(pub u32);
impl Mb464bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord0 {
    #[inline(always)]
    fn default() -> Mb464bWord0 {
        Mb464bWord0(0)
    }
}
impl core::fmt::Debug for Mb464bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord1(pub u32);
impl Mb464bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord1 {
    #[inline(always)]
    fn default() -> Mb464bWord1 {
        Mb464bWord1(0)
    }
}
impl core::fmt::Debug for Mb464bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord10(pub u32);
impl Mb464bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord10 {
    #[inline(always)]
    fn default() -> Mb464bWord10 {
        Mb464bWord10(0)
    }
}
impl core::fmt::Debug for Mb464bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord11(pub u32);
impl Mb464bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord11 {
    #[inline(always)]
    fn default() -> Mb464bWord11 {
        Mb464bWord11(0)
    }
}
impl core::fmt::Debug for Mb464bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord12(pub u32);
impl Mb464bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord12 {
    #[inline(always)]
    fn default() -> Mb464bWord12 {
        Mb464bWord12(0)
    }
}
impl core::fmt::Debug for Mb464bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord13(pub u32);
impl Mb464bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord13 {
    #[inline(always)]
    fn default() -> Mb464bWord13 {
        Mb464bWord13(0)
    }
}
impl core::fmt::Debug for Mb464bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord14(pub u32);
impl Mb464bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord14 {
    #[inline(always)]
    fn default() -> Mb464bWord14 {
        Mb464bWord14(0)
    }
}
impl core::fmt::Debug for Mb464bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord15(pub u32);
impl Mb464bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord15 {
    #[inline(always)]
    fn default() -> Mb464bWord15 {
        Mb464bWord15(0)
    }
}
impl core::fmt::Debug for Mb464bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord2(pub u32);
impl Mb464bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord2 {
    #[inline(always)]
    fn default() -> Mb464bWord2 {
        Mb464bWord2(0)
    }
}
impl core::fmt::Debug for Mb464bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord3(pub u32);
impl Mb464bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord3 {
    #[inline(always)]
    fn default() -> Mb464bWord3 {
        Mb464bWord3(0)
    }
}
impl core::fmt::Debug for Mb464bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord4(pub u32);
impl Mb464bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord4 {
    #[inline(always)]
    fn default() -> Mb464bWord4 {
        Mb464bWord4(0)
    }
}
impl core::fmt::Debug for Mb464bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord5(pub u32);
impl Mb464bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord5 {
    #[inline(always)]
    fn default() -> Mb464bWord5 {
        Mb464bWord5(0)
    }
}
impl core::fmt::Debug for Mb464bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord6(pub u32);
impl Mb464bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord6 {
    #[inline(always)]
    fn default() -> Mb464bWord6 {
        Mb464bWord6(0)
    }
}
impl core::fmt::Debug for Mb464bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord7(pub u32);
impl Mb464bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord7 {
    #[inline(always)]
    fn default() -> Mb464bWord7 {
        Mb464bWord7(0)
    }
}
impl core::fmt::Debug for Mb464bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord8(pub u32);
impl Mb464bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord8 {
    #[inline(always)]
    fn default() -> Mb464bWord8 {
        Mb464bWord8(0)
    }
}
impl core::fmt::Debug for Mb464bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 4 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb464bWord9(pub u32);
impl Mb464bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb464bWord9 {
    #[inline(always)]
    fn default() -> Mb464bWord9 {
        Mb464bWord9(0)
    }
}
impl core::fmt::Debug for Mb464bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb464bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb464bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb464bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 4 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb48bCs(pub u32);
impl Mb48bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb48bCs {
    #[inline(always)]
    fn default() -> Mb48bCs {
        Mb48bCs(0)
    }
}
impl core::fmt::Debug for Mb48bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb48bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb48bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb48bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 4 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb48bId(pub u32);
impl Mb48bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb48bId {
    #[inline(always)]
    fn default() -> Mb48bId {
        Mb48bId(0)
    }
}
impl core::fmt::Debug for Mb48bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb48bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb48bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb48bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 4 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb48bWord0(pub u32);
impl Mb48bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb48bWord0 {
    #[inline(always)]
    fn default() -> Mb48bWord0 {
        Mb48bWord0(0)
    }
}
impl core::fmt::Debug for Mb48bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb48bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb48bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb48bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 4 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb48bWord1(pub u32);
impl Mb48bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb48bWord1 {
    #[inline(always)]
    fn default() -> Mb48bWord1 {
        Mb48bWord1(0)
    }
}
impl core::fmt::Debug for Mb48bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb48bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb48bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb48bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 5 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bCs(pub u32);
impl Mb516bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb516bCs {
    #[inline(always)]
    fn default() -> Mb516bCs {
        Mb516bCs(0)
    }
}
impl core::fmt::Debug for Mb516bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 5 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bId(pub u32);
impl Mb516bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb516bId {
    #[inline(always)]
    fn default() -> Mb516bId {
        Mb516bId(0)
    }
}
impl core::fmt::Debug for Mb516bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 5 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bWord0(pub u32);
impl Mb516bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb516bWord0 {
    #[inline(always)]
    fn default() -> Mb516bWord0 {
        Mb516bWord0(0)
    }
}
impl core::fmt::Debug for Mb516bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 5 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bWord1(pub u32);
impl Mb516bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb516bWord1 {
    #[inline(always)]
    fn default() -> Mb516bWord1 {
        Mb516bWord1(0)
    }
}
impl core::fmt::Debug for Mb516bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 5 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bWord2(pub u32);
impl Mb516bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb516bWord2 {
    #[inline(always)]
    fn default() -> Mb516bWord2 {
        Mb516bWord2(0)
    }
}
impl core::fmt::Debug for Mb516bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 5 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb516bWord3(pub u32);
impl Mb516bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb516bWord3 {
    #[inline(always)]
    fn default() -> Mb516bWord3 {
        Mb516bWord3(0)
    }
}
impl core::fmt::Debug for Mb516bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb516bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb516bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb516bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 5 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bCs(pub u32);
impl Mb532bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb532bCs {
    #[inline(always)]
    fn default() -> Mb532bCs {
        Mb532bCs(0)
    }
}
impl core::fmt::Debug for Mb532bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 5 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bId(pub u32);
impl Mb532bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb532bId {
    #[inline(always)]
    fn default() -> Mb532bId {
        Mb532bId(0)
    }
}
impl core::fmt::Debug for Mb532bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord0(pub u32);
impl Mb532bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord0 {
    #[inline(always)]
    fn default() -> Mb532bWord0 {
        Mb532bWord0(0)
    }
}
impl core::fmt::Debug for Mb532bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord1(pub u32);
impl Mb532bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord1 {
    #[inline(always)]
    fn default() -> Mb532bWord1 {
        Mb532bWord1(0)
    }
}
impl core::fmt::Debug for Mb532bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord2(pub u32);
impl Mb532bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord2 {
    #[inline(always)]
    fn default() -> Mb532bWord2 {
        Mb532bWord2(0)
    }
}
impl core::fmt::Debug for Mb532bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord3(pub u32);
impl Mb532bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord3 {
    #[inline(always)]
    fn default() -> Mb532bWord3 {
        Mb532bWord3(0)
    }
}
impl core::fmt::Debug for Mb532bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord4(pub u32);
impl Mb532bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord4 {
    #[inline(always)]
    fn default() -> Mb532bWord4 {
        Mb532bWord4(0)
    }
}
impl core::fmt::Debug for Mb532bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord5(pub u32);
impl Mb532bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord5 {
    #[inline(always)]
    fn default() -> Mb532bWord5 {
        Mb532bWord5(0)
    }
}
impl core::fmt::Debug for Mb532bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord6(pub u32);
impl Mb532bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord6 {
    #[inline(always)]
    fn default() -> Mb532bWord6 {
        Mb532bWord6(0)
    }
}
impl core::fmt::Debug for Mb532bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 5 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb532bWord7(pub u32);
impl Mb532bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb532bWord7 {
    #[inline(always)]
    fn default() -> Mb532bWord7 {
        Mb532bWord7(0)
    }
}
impl core::fmt::Debug for Mb532bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb532bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb532bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb532bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 5 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bCs(pub u32);
impl Mb564bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb564bCs {
    #[inline(always)]
    fn default() -> Mb564bCs {
        Mb564bCs(0)
    }
}
impl core::fmt::Debug for Mb564bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 5 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bId(pub u32);
impl Mb564bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb564bId {
    #[inline(always)]
    fn default() -> Mb564bId {
        Mb564bId(0)
    }
}
impl core::fmt::Debug for Mb564bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord0(pub u32);
impl Mb564bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord0 {
    #[inline(always)]
    fn default() -> Mb564bWord0 {
        Mb564bWord0(0)
    }
}
impl core::fmt::Debug for Mb564bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord1(pub u32);
impl Mb564bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord1 {
    #[inline(always)]
    fn default() -> Mb564bWord1 {
        Mb564bWord1(0)
    }
}
impl core::fmt::Debug for Mb564bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord10(pub u32);
impl Mb564bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord10 {
    #[inline(always)]
    fn default() -> Mb564bWord10 {
        Mb564bWord10(0)
    }
}
impl core::fmt::Debug for Mb564bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord11(pub u32);
impl Mb564bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord11 {
    #[inline(always)]
    fn default() -> Mb564bWord11 {
        Mb564bWord11(0)
    }
}
impl core::fmt::Debug for Mb564bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord12(pub u32);
impl Mb564bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord12 {
    #[inline(always)]
    fn default() -> Mb564bWord12 {
        Mb564bWord12(0)
    }
}
impl core::fmt::Debug for Mb564bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord13(pub u32);
impl Mb564bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord13 {
    #[inline(always)]
    fn default() -> Mb564bWord13 {
        Mb564bWord13(0)
    }
}
impl core::fmt::Debug for Mb564bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord14(pub u32);
impl Mb564bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord14 {
    #[inline(always)]
    fn default() -> Mb564bWord14 {
        Mb564bWord14(0)
    }
}
impl core::fmt::Debug for Mb564bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord15(pub u32);
impl Mb564bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord15 {
    #[inline(always)]
    fn default() -> Mb564bWord15 {
        Mb564bWord15(0)
    }
}
impl core::fmt::Debug for Mb564bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord2(pub u32);
impl Mb564bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord2 {
    #[inline(always)]
    fn default() -> Mb564bWord2 {
        Mb564bWord2(0)
    }
}
impl core::fmt::Debug for Mb564bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord3(pub u32);
impl Mb564bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord3 {
    #[inline(always)]
    fn default() -> Mb564bWord3 {
        Mb564bWord3(0)
    }
}
impl core::fmt::Debug for Mb564bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord4(pub u32);
impl Mb564bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord4 {
    #[inline(always)]
    fn default() -> Mb564bWord4 {
        Mb564bWord4(0)
    }
}
impl core::fmt::Debug for Mb564bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord5(pub u32);
impl Mb564bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord5 {
    #[inline(always)]
    fn default() -> Mb564bWord5 {
        Mb564bWord5(0)
    }
}
impl core::fmt::Debug for Mb564bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord6(pub u32);
impl Mb564bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord6 {
    #[inline(always)]
    fn default() -> Mb564bWord6 {
        Mb564bWord6(0)
    }
}
impl core::fmt::Debug for Mb564bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord7(pub u32);
impl Mb564bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord7 {
    #[inline(always)]
    fn default() -> Mb564bWord7 {
        Mb564bWord7(0)
    }
}
impl core::fmt::Debug for Mb564bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord8(pub u32);
impl Mb564bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord8 {
    #[inline(always)]
    fn default() -> Mb564bWord8 {
        Mb564bWord8(0)
    }
}
impl core::fmt::Debug for Mb564bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 5 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb564bWord9(pub u32);
impl Mb564bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb564bWord9 {
    #[inline(always)]
    fn default() -> Mb564bWord9 {
        Mb564bWord9(0)
    }
}
impl core::fmt::Debug for Mb564bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb564bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb564bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb564bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 5 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb58bCs(pub u32);
impl Mb58bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb58bCs {
    #[inline(always)]
    fn default() -> Mb58bCs {
        Mb58bCs(0)
    }
}
impl core::fmt::Debug for Mb58bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb58bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb58bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb58bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 5 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb58bId(pub u32);
impl Mb58bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb58bId {
    #[inline(always)]
    fn default() -> Mb58bId {
        Mb58bId(0)
    }
}
impl core::fmt::Debug for Mb58bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb58bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb58bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb58bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 5 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb58bWord0(pub u32);
impl Mb58bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb58bWord0 {
    #[inline(always)]
    fn default() -> Mb58bWord0 {
        Mb58bWord0(0)
    }
}
impl core::fmt::Debug for Mb58bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb58bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb58bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb58bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 5 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb58bWord1(pub u32);
impl Mb58bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb58bWord1 {
    #[inline(always)]
    fn default() -> Mb58bWord1 {
        Mb58bWord1(0)
    }
}
impl core::fmt::Debug for Mb58bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb58bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb58bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb58bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 6 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bCs(pub u32);
impl Mb616bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb616bCs {
    #[inline(always)]
    fn default() -> Mb616bCs {
        Mb616bCs(0)
    }
}
impl core::fmt::Debug for Mb616bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 6 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bId(pub u32);
impl Mb616bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb616bId {
    #[inline(always)]
    fn default() -> Mb616bId {
        Mb616bId(0)
    }
}
impl core::fmt::Debug for Mb616bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 6 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bWord0(pub u32);
impl Mb616bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb616bWord0 {
    #[inline(always)]
    fn default() -> Mb616bWord0 {
        Mb616bWord0(0)
    }
}
impl core::fmt::Debug for Mb616bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 6 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bWord1(pub u32);
impl Mb616bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb616bWord1 {
    #[inline(always)]
    fn default() -> Mb616bWord1 {
        Mb616bWord1(0)
    }
}
impl core::fmt::Debug for Mb616bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 6 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bWord2(pub u32);
impl Mb616bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb616bWord2 {
    #[inline(always)]
    fn default() -> Mb616bWord2 {
        Mb616bWord2(0)
    }
}
impl core::fmt::Debug for Mb616bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 6 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb616bWord3(pub u32);
impl Mb616bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb616bWord3 {
    #[inline(always)]
    fn default() -> Mb616bWord3 {
        Mb616bWord3(0)
    }
}
impl core::fmt::Debug for Mb616bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb616bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb616bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb616bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 6 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bCs(pub u32);
impl Mb632bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb632bCs {
    #[inline(always)]
    fn default() -> Mb632bCs {
        Mb632bCs(0)
    }
}
impl core::fmt::Debug for Mb632bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 6 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bId(pub u32);
impl Mb632bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb632bId {
    #[inline(always)]
    fn default() -> Mb632bId {
        Mb632bId(0)
    }
}
impl core::fmt::Debug for Mb632bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord0(pub u32);
impl Mb632bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord0 {
    #[inline(always)]
    fn default() -> Mb632bWord0 {
        Mb632bWord0(0)
    }
}
impl core::fmt::Debug for Mb632bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord1(pub u32);
impl Mb632bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord1 {
    #[inline(always)]
    fn default() -> Mb632bWord1 {
        Mb632bWord1(0)
    }
}
impl core::fmt::Debug for Mb632bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord2(pub u32);
impl Mb632bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord2 {
    #[inline(always)]
    fn default() -> Mb632bWord2 {
        Mb632bWord2(0)
    }
}
impl core::fmt::Debug for Mb632bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord3(pub u32);
impl Mb632bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord3 {
    #[inline(always)]
    fn default() -> Mb632bWord3 {
        Mb632bWord3(0)
    }
}
impl core::fmt::Debug for Mb632bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord4(pub u32);
impl Mb632bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord4 {
    #[inline(always)]
    fn default() -> Mb632bWord4 {
        Mb632bWord4(0)
    }
}
impl core::fmt::Debug for Mb632bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord5(pub u32);
impl Mb632bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord5 {
    #[inline(always)]
    fn default() -> Mb632bWord5 {
        Mb632bWord5(0)
    }
}
impl core::fmt::Debug for Mb632bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord6(pub u32);
impl Mb632bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord6 {
    #[inline(always)]
    fn default() -> Mb632bWord6 {
        Mb632bWord6(0)
    }
}
impl core::fmt::Debug for Mb632bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 6 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb632bWord7(pub u32);
impl Mb632bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb632bWord7 {
    #[inline(always)]
    fn default() -> Mb632bWord7 {
        Mb632bWord7(0)
    }
}
impl core::fmt::Debug for Mb632bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb632bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb632bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb632bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 6 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bCs(pub u32);
impl Mb664bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb664bCs {
    #[inline(always)]
    fn default() -> Mb664bCs {
        Mb664bCs(0)
    }
}
impl core::fmt::Debug for Mb664bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 6 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bId(pub u32);
impl Mb664bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb664bId {
    #[inline(always)]
    fn default() -> Mb664bId {
        Mb664bId(0)
    }
}
impl core::fmt::Debug for Mb664bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord0(pub u32);
impl Mb664bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord0 {
    #[inline(always)]
    fn default() -> Mb664bWord0 {
        Mb664bWord0(0)
    }
}
impl core::fmt::Debug for Mb664bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord1(pub u32);
impl Mb664bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord1 {
    #[inline(always)]
    fn default() -> Mb664bWord1 {
        Mb664bWord1(0)
    }
}
impl core::fmt::Debug for Mb664bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord10(pub u32);
impl Mb664bWord10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_43(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_43(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_42(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_42(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_41(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_41(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_40(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_40(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord10 {
    #[inline(always)]
    fn default() -> Mb664bWord10 {
        Mb664bWord10(0)
    }
}
impl core::fmt::Debug for Mb664bWord10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord10")
            .field("data_byte_43", &self.data_byte_43())
            .field("data_byte_42", &self.data_byte_42())
            .field("data_byte_41", &self.data_byte_41())
            .field("data_byte_40", &self.data_byte_40())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord10 {{ data_byte_43: {=u8:?}, data_byte_42: {=u8:?}, data_byte_41: {=u8:?}, data_byte_40: {=u8:?} }}",
            self.data_byte_43(),
            self.data_byte_42(),
            self.data_byte_41(),
            self.data_byte_40()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord11(pub u32);
impl Mb664bWord11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_47(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_47(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_46(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_46(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_45(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_45(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_44(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_44(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord11 {
    #[inline(always)]
    fn default() -> Mb664bWord11 {
        Mb664bWord11(0)
    }
}
impl core::fmt::Debug for Mb664bWord11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord11")
            .field("data_byte_47", &self.data_byte_47())
            .field("data_byte_46", &self.data_byte_46())
            .field("data_byte_45", &self.data_byte_45())
            .field("data_byte_44", &self.data_byte_44())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord11 {{ data_byte_47: {=u8:?}, data_byte_46: {=u8:?}, data_byte_45: {=u8:?}, data_byte_44: {=u8:?} }}",
            self.data_byte_47(),
            self.data_byte_46(),
            self.data_byte_45(),
            self.data_byte_44()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord12(pub u32);
impl Mb664bWord12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_51(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_51(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_50(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_50(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_49(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_49(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_48(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_48(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord12 {
    #[inline(always)]
    fn default() -> Mb664bWord12 {
        Mb664bWord12(0)
    }
}
impl core::fmt::Debug for Mb664bWord12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord12")
            .field("data_byte_51", &self.data_byte_51())
            .field("data_byte_50", &self.data_byte_50())
            .field("data_byte_49", &self.data_byte_49())
            .field("data_byte_48", &self.data_byte_48())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord12 {{ data_byte_51: {=u8:?}, data_byte_50: {=u8:?}, data_byte_49: {=u8:?}, data_byte_48: {=u8:?} }}",
            self.data_byte_51(),
            self.data_byte_50(),
            self.data_byte_49(),
            self.data_byte_48()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord13(pub u32);
impl Mb664bWord13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_55(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_55(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_54(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_54(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_53(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_53(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_52(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_52(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord13 {
    #[inline(always)]
    fn default() -> Mb664bWord13 {
        Mb664bWord13(0)
    }
}
impl core::fmt::Debug for Mb664bWord13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord13")
            .field("data_byte_55", &self.data_byte_55())
            .field("data_byte_54", &self.data_byte_54())
            .field("data_byte_53", &self.data_byte_53())
            .field("data_byte_52", &self.data_byte_52())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord13 {{ data_byte_55: {=u8:?}, data_byte_54: {=u8:?}, data_byte_53: {=u8:?}, data_byte_52: {=u8:?} }}",
            self.data_byte_55(),
            self.data_byte_54(),
            self.data_byte_53(),
            self.data_byte_52()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord14(pub u32);
impl Mb664bWord14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_59(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_59(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_58(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_58(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_57(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_57(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_56(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_56(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord14 {
    #[inline(always)]
    fn default() -> Mb664bWord14 {
        Mb664bWord14(0)
    }
}
impl core::fmt::Debug for Mb664bWord14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord14")
            .field("data_byte_59", &self.data_byte_59())
            .field("data_byte_58", &self.data_byte_58())
            .field("data_byte_57", &self.data_byte_57())
            .field("data_byte_56", &self.data_byte_56())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord14 {{ data_byte_59: {=u8:?}, data_byte_58: {=u8:?}, data_byte_57: {=u8:?}, data_byte_56: {=u8:?} }}",
            self.data_byte_59(),
            self.data_byte_58(),
            self.data_byte_57(),
            self.data_byte_56()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord15(pub u32);
impl Mb664bWord15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_63(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_63(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_62(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_62(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_61(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_61(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_60(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_60(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord15 {
    #[inline(always)]
    fn default() -> Mb664bWord15 {
        Mb664bWord15(0)
    }
}
impl core::fmt::Debug for Mb664bWord15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord15")
            .field("data_byte_63", &self.data_byte_63())
            .field("data_byte_62", &self.data_byte_62())
            .field("data_byte_61", &self.data_byte_61())
            .field("data_byte_60", &self.data_byte_60())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord15 {{ data_byte_63: {=u8:?}, data_byte_62: {=u8:?}, data_byte_61: {=u8:?}, data_byte_60: {=u8:?} }}",
            self.data_byte_63(),
            self.data_byte_62(),
            self.data_byte_61(),
            self.data_byte_60()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord2(pub u32);
impl Mb664bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord2 {
    #[inline(always)]
    fn default() -> Mb664bWord2 {
        Mb664bWord2(0)
    }
}
impl core::fmt::Debug for Mb664bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord3(pub u32);
impl Mb664bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord3 {
    #[inline(always)]
    fn default() -> Mb664bWord3 {
        Mb664bWord3(0)
    }
}
impl core::fmt::Debug for Mb664bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord4(pub u32);
impl Mb664bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord4 {
    #[inline(always)]
    fn default() -> Mb664bWord4 {
        Mb664bWord4(0)
    }
}
impl core::fmt::Debug for Mb664bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord5(pub u32);
impl Mb664bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord5 {
    #[inline(always)]
    fn default() -> Mb664bWord5 {
        Mb664bWord5(0)
    }
}
impl core::fmt::Debug for Mb664bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord6(pub u32);
impl Mb664bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord6 {
    #[inline(always)]
    fn default() -> Mb664bWord6 {
        Mb664bWord6(0)
    }
}
impl core::fmt::Debug for Mb664bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord7(pub u32);
impl Mb664bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord7 {
    #[inline(always)]
    fn default() -> Mb664bWord7 {
        Mb664bWord7(0)
    }
}
impl core::fmt::Debug for Mb664bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord8(pub u32);
impl Mb664bWord8 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_35(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_35(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_34(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_34(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_33(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_33(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_32(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_32(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord8 {
    #[inline(always)]
    fn default() -> Mb664bWord8 {
        Mb664bWord8(0)
    }
}
impl core::fmt::Debug for Mb664bWord8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord8")
            .field("data_byte_35", &self.data_byte_35())
            .field("data_byte_34", &self.data_byte_34())
            .field("data_byte_33", &self.data_byte_33())
            .field("data_byte_32", &self.data_byte_32())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord8 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord8 {{ data_byte_35: {=u8:?}, data_byte_34: {=u8:?}, data_byte_33: {=u8:?}, data_byte_32: {=u8:?} }}",
            self.data_byte_35(),
            self.data_byte_34(),
            self.data_byte_33(),
            self.data_byte_32()
        )
    }
}
#[doc = "Message Buffer 6 WORD_64B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb664bWord9(pub u32);
impl Mb664bWord9 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_39(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_39(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_38(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_38(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_37(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_37(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_36(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_36(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb664bWord9 {
    #[inline(always)]
    fn default() -> Mb664bWord9 {
        Mb664bWord9(0)
    }
}
impl core::fmt::Debug for Mb664bWord9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb664bWord9")
            .field("data_byte_39", &self.data_byte_39())
            .field("data_byte_38", &self.data_byte_38())
            .field("data_byte_37", &self.data_byte_37())
            .field("data_byte_36", &self.data_byte_36())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb664bWord9 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb664bWord9 {{ data_byte_39: {=u8:?}, data_byte_38: {=u8:?}, data_byte_37: {=u8:?}, data_byte_36: {=u8:?} }}",
            self.data_byte_39(),
            self.data_byte_38(),
            self.data_byte_37(),
            self.data_byte_36()
        )
    }
}
#[doc = "Message Buffer 6 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb68bCs(pub u32);
impl Mb68bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb68bCs {
    #[inline(always)]
    fn default() -> Mb68bCs {
        Mb68bCs(0)
    }
}
impl core::fmt::Debug for Mb68bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb68bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb68bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb68bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 6 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb68bId(pub u32);
impl Mb68bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb68bId {
    #[inline(always)]
    fn default() -> Mb68bId {
        Mb68bId(0)
    }
}
impl core::fmt::Debug for Mb68bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb68bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb68bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb68bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 6 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb68bWord0(pub u32);
impl Mb68bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb68bWord0 {
    #[inline(always)]
    fn default() -> Mb68bWord0 {
        Mb68bWord0(0)
    }
}
impl core::fmt::Debug for Mb68bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb68bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb68bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb68bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 6 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb68bWord1(pub u32);
impl Mb68bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb68bWord1 {
    #[inline(always)]
    fn default() -> Mb68bWord1 {
        Mb68bWord1(0)
    }
}
impl core::fmt::Debug for Mb68bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb68bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb68bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb68bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 7 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bCs(pub u32);
impl Mb716bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb716bCs {
    #[inline(always)]
    fn default() -> Mb716bCs {
        Mb716bCs(0)
    }
}
impl core::fmt::Debug for Mb716bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 7 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bId(pub u32);
impl Mb716bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb716bId {
    #[inline(always)]
    fn default() -> Mb716bId {
        Mb716bId(0)
    }
}
impl core::fmt::Debug for Mb716bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 7 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bWord0(pub u32);
impl Mb716bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb716bWord0 {
    #[inline(always)]
    fn default() -> Mb716bWord0 {
        Mb716bWord0(0)
    }
}
impl core::fmt::Debug for Mb716bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 7 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bWord1(pub u32);
impl Mb716bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb716bWord1 {
    #[inline(always)]
    fn default() -> Mb716bWord1 {
        Mb716bWord1(0)
    }
}
impl core::fmt::Debug for Mb716bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 7 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bWord2(pub u32);
impl Mb716bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb716bWord2 {
    #[inline(always)]
    fn default() -> Mb716bWord2 {
        Mb716bWord2(0)
    }
}
impl core::fmt::Debug for Mb716bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 7 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb716bWord3(pub u32);
impl Mb716bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb716bWord3 {
    #[inline(always)]
    fn default() -> Mb716bWord3 {
        Mb716bWord3(0)
    }
}
impl core::fmt::Debug for Mb716bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb716bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb716bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb716bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 7 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bCs(pub u32);
impl Mb732bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb732bCs {
    #[inline(always)]
    fn default() -> Mb732bCs {
        Mb732bCs(0)
    }
}
impl core::fmt::Debug for Mb732bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 7 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bId(pub u32);
impl Mb732bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb732bId {
    #[inline(always)]
    fn default() -> Mb732bId {
        Mb732bId(0)
    }
}
impl core::fmt::Debug for Mb732bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord0(pub u32);
impl Mb732bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord0 {
    #[inline(always)]
    fn default() -> Mb732bWord0 {
        Mb732bWord0(0)
    }
}
impl core::fmt::Debug for Mb732bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord1(pub u32);
impl Mb732bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord1 {
    #[inline(always)]
    fn default() -> Mb732bWord1 {
        Mb732bWord1(0)
    }
}
impl core::fmt::Debug for Mb732bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord2(pub u32);
impl Mb732bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord2 {
    #[inline(always)]
    fn default() -> Mb732bWord2 {
        Mb732bWord2(0)
    }
}
impl core::fmt::Debug for Mb732bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord3(pub u32);
impl Mb732bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord3 {
    #[inline(always)]
    fn default() -> Mb732bWord3 {
        Mb732bWord3(0)
    }
}
impl core::fmt::Debug for Mb732bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord4(pub u32);
impl Mb732bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord4 {
    #[inline(always)]
    fn default() -> Mb732bWord4 {
        Mb732bWord4(0)
    }
}
impl core::fmt::Debug for Mb732bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord5(pub u32);
impl Mb732bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord5 {
    #[inline(always)]
    fn default() -> Mb732bWord5 {
        Mb732bWord5(0)
    }
}
impl core::fmt::Debug for Mb732bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord6(pub u32);
impl Mb732bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord6 {
    #[inline(always)]
    fn default() -> Mb732bWord6 {
        Mb732bWord6(0)
    }
}
impl core::fmt::Debug for Mb732bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 7 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb732bWord7(pub u32);
impl Mb732bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb732bWord7 {
    #[inline(always)]
    fn default() -> Mb732bWord7 {
        Mb732bWord7(0)
    }
}
impl core::fmt::Debug for Mb732bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb732bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb732bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb732bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 7 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb78bCs(pub u32);
impl Mb78bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb78bCs {
    #[inline(always)]
    fn default() -> Mb78bCs {
        Mb78bCs(0)
    }
}
impl core::fmt::Debug for Mb78bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb78bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb78bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb78bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 7 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb78bId(pub u32);
impl Mb78bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb78bId {
    #[inline(always)]
    fn default() -> Mb78bId {
        Mb78bId(0)
    }
}
impl core::fmt::Debug for Mb78bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb78bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb78bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb78bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 7 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb78bWord0(pub u32);
impl Mb78bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb78bWord0 {
    #[inline(always)]
    fn default() -> Mb78bWord0 {
        Mb78bWord0(0)
    }
}
impl core::fmt::Debug for Mb78bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb78bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb78bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb78bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 7 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb78bWord1(pub u32);
impl Mb78bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb78bWord1 {
    #[inline(always)]
    fn default() -> Mb78bWord1 {
        Mb78bWord1(0)
    }
}
impl core::fmt::Debug for Mb78bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb78bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb78bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb78bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 8 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bCs(pub u32);
impl Mb816bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb816bCs {
    #[inline(always)]
    fn default() -> Mb816bCs {
        Mb816bCs(0)
    }
}
impl core::fmt::Debug for Mb816bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 8 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bId(pub u32);
impl Mb816bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb816bId {
    #[inline(always)]
    fn default() -> Mb816bId {
        Mb816bId(0)
    }
}
impl core::fmt::Debug for Mb816bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 8 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bWord0(pub u32);
impl Mb816bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb816bWord0 {
    #[inline(always)]
    fn default() -> Mb816bWord0 {
        Mb816bWord0(0)
    }
}
impl core::fmt::Debug for Mb816bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 8 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bWord1(pub u32);
impl Mb816bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb816bWord1 {
    #[inline(always)]
    fn default() -> Mb816bWord1 {
        Mb816bWord1(0)
    }
}
impl core::fmt::Debug for Mb816bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 8 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bWord2(pub u32);
impl Mb816bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb816bWord2 {
    #[inline(always)]
    fn default() -> Mb816bWord2 {
        Mb816bWord2(0)
    }
}
impl core::fmt::Debug for Mb816bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 8 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb816bWord3(pub u32);
impl Mb816bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb816bWord3 {
    #[inline(always)]
    fn default() -> Mb816bWord3 {
        Mb816bWord3(0)
    }
}
impl core::fmt::Debug for Mb816bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb816bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb816bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb816bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 8 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bCs(pub u32);
impl Mb832bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb832bCs {
    #[inline(always)]
    fn default() -> Mb832bCs {
        Mb832bCs(0)
    }
}
impl core::fmt::Debug for Mb832bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 8 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bId(pub u32);
impl Mb832bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb832bId {
    #[inline(always)]
    fn default() -> Mb832bId {
        Mb832bId(0)
    }
}
impl core::fmt::Debug for Mb832bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord0(pub u32);
impl Mb832bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord0 {
    #[inline(always)]
    fn default() -> Mb832bWord0 {
        Mb832bWord0(0)
    }
}
impl core::fmt::Debug for Mb832bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord1(pub u32);
impl Mb832bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord1 {
    #[inline(always)]
    fn default() -> Mb832bWord1 {
        Mb832bWord1(0)
    }
}
impl core::fmt::Debug for Mb832bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord2(pub u32);
impl Mb832bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord2 {
    #[inline(always)]
    fn default() -> Mb832bWord2 {
        Mb832bWord2(0)
    }
}
impl core::fmt::Debug for Mb832bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord3(pub u32);
impl Mb832bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord3 {
    #[inline(always)]
    fn default() -> Mb832bWord3 {
        Mb832bWord3(0)
    }
}
impl core::fmt::Debug for Mb832bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord4(pub u32);
impl Mb832bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord4 {
    #[inline(always)]
    fn default() -> Mb832bWord4 {
        Mb832bWord4(0)
    }
}
impl core::fmt::Debug for Mb832bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord5(pub u32);
impl Mb832bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord5 {
    #[inline(always)]
    fn default() -> Mb832bWord5 {
        Mb832bWord5(0)
    }
}
impl core::fmt::Debug for Mb832bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord6(pub u32);
impl Mb832bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord6 {
    #[inline(always)]
    fn default() -> Mb832bWord6 {
        Mb832bWord6(0)
    }
}
impl core::fmt::Debug for Mb832bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 8 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb832bWord7(pub u32);
impl Mb832bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb832bWord7 {
    #[inline(always)]
    fn default() -> Mb832bWord7 {
        Mb832bWord7(0)
    }
}
impl core::fmt::Debug for Mb832bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb832bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb832bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb832bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 8 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb88bCs(pub u32);
impl Mb88bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb88bCs {
    #[inline(always)]
    fn default() -> Mb88bCs {
        Mb88bCs(0)
    }
}
impl core::fmt::Debug for Mb88bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb88bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb88bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb88bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 8 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb88bId(pub u32);
impl Mb88bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb88bId {
    #[inline(always)]
    fn default() -> Mb88bId {
        Mb88bId(0)
    }
}
impl core::fmt::Debug for Mb88bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb88bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb88bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb88bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 8 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb88bWord0(pub u32);
impl Mb88bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb88bWord0 {
    #[inline(always)]
    fn default() -> Mb88bWord0 {
        Mb88bWord0(0)
    }
}
impl core::fmt::Debug for Mb88bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb88bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb88bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb88bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 8 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb88bWord1(pub u32);
impl Mb88bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb88bWord1 {
    #[inline(always)]
    fn default() -> Mb88bWord1 {
        Mb88bWord1(0)
    }
}
impl core::fmt::Debug for Mb88bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb88bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb88bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb88bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 9 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bCs(pub u32);
impl Mb916bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb916bCs {
    #[inline(always)]
    fn default() -> Mb916bCs {
        Mb916bCs(0)
    }
}
impl core::fmt::Debug for Mb916bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 9 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bId(pub u32);
impl Mb916bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb916bId {
    #[inline(always)]
    fn default() -> Mb916bId {
        Mb916bId(0)
    }
}
impl core::fmt::Debug for Mb916bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 9 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bWord0(pub u32);
impl Mb916bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb916bWord0 {
    #[inline(always)]
    fn default() -> Mb916bWord0 {
        Mb916bWord0(0)
    }
}
impl core::fmt::Debug for Mb916bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 9 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bWord1(pub u32);
impl Mb916bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb916bWord1 {
    #[inline(always)]
    fn default() -> Mb916bWord1 {
        Mb916bWord1(0)
    }
}
impl core::fmt::Debug for Mb916bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 9 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bWord2(pub u32);
impl Mb916bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb916bWord2 {
    #[inline(always)]
    fn default() -> Mb916bWord2 {
        Mb916bWord2(0)
    }
}
impl core::fmt::Debug for Mb916bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 9 WORD_16B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb916bWord3(pub u32);
impl Mb916bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb916bWord3 {
    #[inline(always)]
    fn default() -> Mb916bWord3 {
        Mb916bWord3(0)
    }
}
impl core::fmt::Debug for Mb916bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb916bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb916bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb916bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 9 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bCs(pub u32);
impl Mb932bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb932bCs {
    #[inline(always)]
    fn default() -> Mb932bCs {
        Mb932bCs(0)
    }
}
impl core::fmt::Debug for Mb932bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 9 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bId(pub u32);
impl Mb932bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb932bId {
    #[inline(always)]
    fn default() -> Mb932bId {
        Mb932bId(0)
    }
}
impl core::fmt::Debug for Mb932bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord0(pub u32);
impl Mb932bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord0 {
    #[inline(always)]
    fn default() -> Mb932bWord0 {
        Mb932bWord0(0)
    }
}
impl core::fmt::Debug for Mb932bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord1(pub u32);
impl Mb932bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord1 {
    #[inline(always)]
    fn default() -> Mb932bWord1 {
        Mb932bWord1(0)
    }
}
impl core::fmt::Debug for Mb932bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord2(pub u32);
impl Mb932bWord2 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_11(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_11(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_10(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_10(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_9(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_9(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_8(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_8(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord2 {
    #[inline(always)]
    fn default() -> Mb932bWord2 {
        Mb932bWord2(0)
    }
}
impl core::fmt::Debug for Mb932bWord2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord2")
            .field("data_byte_11", &self.data_byte_11())
            .field("data_byte_10", &self.data_byte_10())
            .field("data_byte_9", &self.data_byte_9())
            .field("data_byte_8", &self.data_byte_8())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord2 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord2 {{ data_byte_11: {=u8:?}, data_byte_10: {=u8:?}, data_byte_9: {=u8:?}, data_byte_8: {=u8:?} }}",
            self.data_byte_11(),
            self.data_byte_10(),
            self.data_byte_9(),
            self.data_byte_8()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord3(pub u32);
impl Mb932bWord3 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_15(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_15(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_14(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_14(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_13(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_13(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_12(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_12(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord3 {
    #[inline(always)]
    fn default() -> Mb932bWord3 {
        Mb932bWord3(0)
    }
}
impl core::fmt::Debug for Mb932bWord3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord3")
            .field("data_byte_15", &self.data_byte_15())
            .field("data_byte_14", &self.data_byte_14())
            .field("data_byte_13", &self.data_byte_13())
            .field("data_byte_12", &self.data_byte_12())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord3 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord3 {{ data_byte_15: {=u8:?}, data_byte_14: {=u8:?}, data_byte_13: {=u8:?}, data_byte_12: {=u8:?} }}",
            self.data_byte_15(),
            self.data_byte_14(),
            self.data_byte_13(),
            self.data_byte_12()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord4(pub u32);
impl Mb932bWord4 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_19(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_19(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_18(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_18(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_17(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_17(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_16(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_16(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord4 {
    #[inline(always)]
    fn default() -> Mb932bWord4 {
        Mb932bWord4(0)
    }
}
impl core::fmt::Debug for Mb932bWord4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord4")
            .field("data_byte_19", &self.data_byte_19())
            .field("data_byte_18", &self.data_byte_18())
            .field("data_byte_17", &self.data_byte_17())
            .field("data_byte_16", &self.data_byte_16())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord4 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord4 {{ data_byte_19: {=u8:?}, data_byte_18: {=u8:?}, data_byte_17: {=u8:?}, data_byte_16: {=u8:?} }}",
            self.data_byte_19(),
            self.data_byte_18(),
            self.data_byte_17(),
            self.data_byte_16()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord5(pub u32);
impl Mb932bWord5 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_23(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_23(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_22(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_22(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_21(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_21(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_20(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_20(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord5 {
    #[inline(always)]
    fn default() -> Mb932bWord5 {
        Mb932bWord5(0)
    }
}
impl core::fmt::Debug for Mb932bWord5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord5")
            .field("data_byte_23", &self.data_byte_23())
            .field("data_byte_22", &self.data_byte_22())
            .field("data_byte_21", &self.data_byte_21())
            .field("data_byte_20", &self.data_byte_20())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord5 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord5 {{ data_byte_23: {=u8:?}, data_byte_22: {=u8:?}, data_byte_21: {=u8:?}, data_byte_20: {=u8:?} }}",
            self.data_byte_23(),
            self.data_byte_22(),
            self.data_byte_21(),
            self.data_byte_20()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord6(pub u32);
impl Mb932bWord6 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_27(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_27(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_26(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_26(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_25(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_25(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_24(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_24(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord6 {
    #[inline(always)]
    fn default() -> Mb932bWord6 {
        Mb932bWord6(0)
    }
}
impl core::fmt::Debug for Mb932bWord6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord6")
            .field("data_byte_27", &self.data_byte_27())
            .field("data_byte_26", &self.data_byte_26())
            .field("data_byte_25", &self.data_byte_25())
            .field("data_byte_24", &self.data_byte_24())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord6 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord6 {{ data_byte_27: {=u8:?}, data_byte_26: {=u8:?}, data_byte_25: {=u8:?}, data_byte_24: {=u8:?} }}",
            self.data_byte_27(),
            self.data_byte_26(),
            self.data_byte_25(),
            self.data_byte_24()
        )
    }
}
#[doc = "Message Buffer 9 WORD_32B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb932bWord7(pub u32);
impl Mb932bWord7 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_31(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_31(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_30(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_30(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_29(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_29(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_28(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_28(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb932bWord7 {
    #[inline(always)]
    fn default() -> Mb932bWord7 {
        Mb932bWord7(0)
    }
}
impl core::fmt::Debug for Mb932bWord7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb932bWord7")
            .field("data_byte_31", &self.data_byte_31())
            .field("data_byte_30", &self.data_byte_30())
            .field("data_byte_29", &self.data_byte_29())
            .field("data_byte_28", &self.data_byte_28())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb932bWord7 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb932bWord7 {{ data_byte_31: {=u8:?}, data_byte_30: {=u8:?}, data_byte_29: {=u8:?}, data_byte_28: {=u8:?} }}",
            self.data_byte_31(),
            self.data_byte_30(),
            self.data_byte_29(),
            self.data_byte_28()
        )
    }
}
#[doc = "Message Buffer 9 CS Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb98bCs(pub u32);
impl Mb98bCs {
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[must_use]
    #[inline(always)]
    pub const fn time_stamp(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus."]
    #[inline(always)]
    pub const fn set_time_stamp(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of the data to be stored/transmitted."]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request. One/zero for remote/data frame."]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "ID Extended. One/zero for extended/standard format frame."]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "Substitute Remote Request. Contains a fixed recessive bit."]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[must_use]
    #[inline(always)]
    pub const fn code(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0x0f;
        val as u8
    }
    #[doc = "Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process."]
    #[inline(always)]
    pub const fn set_code(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[must_use]
    #[inline(always)]
    pub const fn esi(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Error State Indicator. This bit indicates if the transmitting node is error active or error passive."]
    #[inline(always)]
    pub const fn set_esi(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[must_use]
    #[inline(always)]
    pub const fn brs(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame."]
    #[inline(always)]
    pub const fn set_brs(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[must_use]
    #[inline(always)]
    pub const fn edl(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010."]
    #[inline(always)]
    pub const fn set_edl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for Mb98bCs {
    #[inline(always)]
    fn default() -> Mb98bCs {
        Mb98bCs(0)
    }
}
impl core::fmt::Debug for Mb98bCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb98bCs")
            .field("time_stamp", &self.time_stamp())
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .field("code", &self.code())
            .field("esi", &self.esi())
            .field("brs", &self.brs())
            .field("edl", &self.edl())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb98bCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb98bCs {{ time_stamp: {=u16:?}, dlc: {=u8:?}, rtr: {=bool:?}, ide: {=bool:?}, srr: {=bool:?}, code: {=u8:?}, esi: {=bool:?}, brs: {=bool:?}, edl: {=bool:?} }}",
            self.time_stamp(),
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr(),
            self.code(),
            self.esi(),
            self.brs(),
            self.edl()
        )
    }
}
#[doc = "Message Buffer 9 ID Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb98bId(pub u32);
impl Mb98bId {
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn ext(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x0003_ffff;
        val as u32
    }
    #[doc = "Contains extended (LOW word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_ext(&mut self, val: u32) {
        self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[must_use]
    #[inline(always)]
    pub const fn std(&self) -> u16 {
        let val = (self.0 >> 18usize) & 0x07ff;
        val as u16
    }
    #[doc = "Contains standard/extended (HIGH word) identifier of message buffer."]
    #[inline(always)]
    pub const fn set_std(&mut self, val: u16) {
        self.0 = (self.0 & !(0x07ff << 18usize)) | (((val as u32) & 0x07ff) << 18usize);
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[must_use]
    #[inline(always)]
    pub const fn prio(&self) -> u8 {
        let val = (self.0 >> 29usize) & 0x07;
        val as u8
    }
    #[doc = "Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority."]
    #[inline(always)]
    pub const fn set_prio(&mut self, val: u8) {
        self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
    }
}
impl Default for Mb98bId {
    #[inline(always)]
    fn default() -> Mb98bId {
        Mb98bId(0)
    }
}
impl core::fmt::Debug for Mb98bId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb98bId")
            .field("ext", &self.ext())
            .field("std", &self.std())
            .field("prio", &self.prio())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb98bId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb98bId {{ ext: {=u32:?}, std: {=u16:?}, prio: {=u8:?} }}",
            self.ext(),
            self.std(),
            self.prio()
        )
    }
}
#[doc = "Message Buffer 9 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb98bWord0(pub u32);
impl Mb98bWord0 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb98bWord0 {
    #[inline(always)]
    fn default() -> Mb98bWord0 {
        Mb98bWord0(0)
    }
}
impl core::fmt::Debug for Mb98bWord0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb98bWord0")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb98bWord0 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb98bWord0 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 9 WORD_8B Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mb98bWord1(pub u32);
impl Mb98bWord1 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Mb98bWord1 {
    #[inline(always)]
    fn default() -> Mb98bWord1 {
        Mb98bWord1(0)
    }
}
impl core::fmt::Debug for Mb98bWord1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mb98bWord1")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mb98bWord1 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mb98bWord1 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Module Configuration"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mcr(pub u32);
impl Mcr {
    #[doc = "Number of the Last Message Buffer"]
    #[must_use]
    #[inline(always)]
    pub const fn maxmb(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0x7f;
        val as u8
    }
    #[doc = "Number of the Last Message Buffer"]
    #[inline(always)]
    pub const fn set_maxmb(&mut self, val: u8) {
        self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
    }
    #[doc = "ID Acceptance Mode"]
    #[must_use]
    #[inline(always)]
    pub const fn idam(&self) -> super::vals::Idam {
        let val = (self.0 >> 8usize) & 0x03;
        super::vals::Idam::from_bits(val as u8)
    }
    #[doc = "ID Acceptance Mode"]
    #[inline(always)]
    pub const fn set_idam(&mut self, val: super::vals::Idam) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
    }
    #[doc = "CAN FD Operation Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn fden(&self) -> super::vals::Fden {
        let val = (self.0 >> 11usize) & 0x01;
        super::vals::Fden::from_bits(val as u8)
    }
    #[doc = "CAN FD Operation Enable"]
    #[inline(always)]
    pub const fn set_fden(&mut self, val: super::vals::Fden) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
    }
    #[doc = "Abort Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn aen(&self) -> super::vals::Aen {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::Aen::from_bits(val as u8)
    }
    #[doc = "Abort Enable"]
    #[inline(always)]
    pub const fn set_aen(&mut self, val: super::vals::Aen) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Local Priority Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn lprioen(&self) -> super::vals::Lprioen {
        let val = (self.0 >> 13usize) & 0x01;
        super::vals::Lprioen::from_bits(val as u8)
    }
    #[doc = "Local Priority Enable"]
    #[inline(always)]
    pub const fn set_lprioen(&mut self, val: super::vals::Lprioen) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
    }
    #[doc = "Pretended Networking Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn pnet_en(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "Pretended Networking Enable"]
    #[inline(always)]
    pub const fn set_pnet_en(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "DMA Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn dma(&self) -> super::vals::Dma {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::Dma::from_bits(val as u8)
    }
    #[doc = "DMA Enable"]
    #[inline(always)]
    pub const fn set_dma(&mut self, val: super::vals::Dma) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "Individual RX Masking and Queue Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn irmq(&self) -> super::vals::Irmq {
        let val = (self.0 >> 16usize) & 0x01;
        super::vals::Irmq::from_bits(val as u8)
    }
    #[doc = "Individual RX Masking and Queue Enable"]
    #[inline(always)]
    pub const fn set_irmq(&mut self, val: super::vals::Irmq) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
    }
    #[doc = "Self-Reception Disable"]
    #[must_use]
    #[inline(always)]
    pub const fn srxdis(&self) -> super::vals::Srxdis {
        let val = (self.0 >> 17usize) & 0x01;
        super::vals::Srxdis::from_bits(val as u8)
    }
    #[doc = "Self-Reception Disable"]
    #[inline(always)]
    pub const fn set_srxdis(&mut self, val: super::vals::Srxdis) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
    }
    #[doc = "Wake-Up Source"]
    #[must_use]
    #[inline(always)]
    pub const fn waksrc(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-Up Source"]
    #[inline(always)]
    pub const fn set_waksrc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "Low-Power Mode Acknowledge"]
    #[must_use]
    #[inline(always)]
    pub const fn lpmack(&self) -> super::vals::Lpmack {
        let val = (self.0 >> 20usize) & 0x01;
        super::vals::Lpmack::from_bits(val as u8)
    }
    #[doc = "Low-Power Mode Acknowledge"]
    #[inline(always)]
    pub const fn set_lpmack(&mut self, val: super::vals::Lpmack) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
    }
    #[doc = "Warning Interrupt Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn wrnen(&self) -> super::vals::Wrnen {
        let val = (self.0 >> 21usize) & 0x01;
        super::vals::Wrnen::from_bits(val as u8)
    }
    #[doc = "Warning Interrupt Enable"]
    #[inline(always)]
    pub const fn set_wrnen(&mut self, val: super::vals::Wrnen) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
    }
    #[doc = "Self Wake-up"]
    #[must_use]
    #[inline(always)]
    pub const fn slfwak(&self) -> super::vals::Slfwak {
        let val = (self.0 >> 22usize) & 0x01;
        super::vals::Slfwak::from_bits(val as u8)
    }
    #[doc = "Self Wake-up"]
    #[inline(always)]
    pub const fn set_slfwak(&mut self, val: super::vals::Slfwak) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
    }
    #[doc = "Freeze Mode Acknowledge"]
    #[must_use]
    #[inline(always)]
    pub const fn frzack(&self) -> super::vals::Frzack {
        let val = (self.0 >> 24usize) & 0x01;
        super::vals::Frzack::from_bits(val as u8)
    }
    #[doc = "Freeze Mode Acknowledge"]
    #[inline(always)]
    pub const fn set_frzack(&mut self, val: super::vals::Frzack) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
    }
    #[doc = "Soft Reset"]
    #[must_use]
    #[inline(always)]
    pub const fn softrst(&self) -> super::vals::Softrst {
        let val = (self.0 >> 25usize) & 0x01;
        super::vals::Softrst::from_bits(val as u8)
    }
    #[doc = "Soft Reset"]
    #[inline(always)]
    pub const fn set_softrst(&mut self, val: super::vals::Softrst) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
    }
    #[doc = "Wake-up Interrupt Mask"]
    #[must_use]
    #[inline(always)]
    pub const fn wakmsk(&self) -> super::vals::Wakmsk {
        let val = (self.0 >> 26usize) & 0x01;
        super::vals::Wakmsk::from_bits(val as u8)
    }
    #[doc = "Wake-up Interrupt Mask"]
    #[inline(always)]
    pub const fn set_wakmsk(&mut self, val: super::vals::Wakmsk) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
    }
    #[doc = "FlexCAN Not Ready"]
    #[must_use]
    #[inline(always)]
    pub const fn notrdy(&self) -> super::vals::Notrdy {
        let val = (self.0 >> 27usize) & 0x01;
        super::vals::Notrdy::from_bits(val as u8)
    }
    #[doc = "FlexCAN Not Ready"]
    #[inline(always)]
    pub const fn set_notrdy(&mut self, val: super::vals::Notrdy) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
    }
    #[doc = "Halt FlexCAN"]
    #[must_use]
    #[inline(always)]
    pub const fn halt(&self) -> super::vals::Halt {
        let val = (self.0 >> 28usize) & 0x01;
        super::vals::Halt::from_bits(val as u8)
    }
    #[doc = "Halt FlexCAN"]
    #[inline(always)]
    pub const fn set_halt(&mut self, val: super::vals::Halt) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
    }
    #[doc = "Legacy RX FIFO Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn rfen(&self) -> super::vals::Rfen {
        let val = (self.0 >> 29usize) & 0x01;
        super::vals::Rfen::from_bits(val as u8)
    }
    #[doc = "Legacy RX FIFO Enable"]
    #[inline(always)]
    pub const fn set_rfen(&mut self, val: super::vals::Rfen) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
    }
    #[doc = "Freeze Enable"]
    #[must_use]
    #[inline(always)]
    pub const fn frz(&self) -> super::vals::Frz {
        let val = (self.0 >> 30usize) & 0x01;
        super::vals::Frz::from_bits(val as u8)
    }
    #[doc = "Freeze Enable"]
    #[inline(always)]
    pub const fn set_frz(&mut self, val: super::vals::Frz) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
    }
    #[doc = "Module Disable"]
    #[must_use]
    #[inline(always)]
    pub const fn mdis(&self) -> super::vals::Mdis {
        let val = (self.0 >> 31usize) & 0x01;
        super::vals::Mdis::from_bits(val as u8)
    }
    #[doc = "Module Disable"]
    #[inline(always)]
    pub const fn set_mdis(&mut self, val: super::vals::Mdis) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
    }
}
impl Default for Mcr {
    #[inline(always)]
    fn default() -> Mcr {
        Mcr(0)
    }
}
impl core::fmt::Debug for Mcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcr")
            .field("maxmb", &self.maxmb())
            .field("idam", &self.idam())
            .field("fden", &self.fden())
            .field("aen", &self.aen())
            .field("lprioen", &self.lprioen())
            .field("pnet_en", &self.pnet_en())
            .field("dma", &self.dma())
            .field("irmq", &self.irmq())
            .field("srxdis", &self.srxdis())
            .field("waksrc", &self.waksrc())
            .field("lpmack", &self.lpmack())
            .field("wrnen", &self.wrnen())
            .field("slfwak", &self.slfwak())
            .field("frzack", &self.frzack())
            .field("softrst", &self.softrst())
            .field("wakmsk", &self.wakmsk())
            .field("notrdy", &self.notrdy())
            .field("halt", &self.halt())
            .field("rfen", &self.rfen())
            .field("frz", &self.frz())
            .field("mdis", &self.mdis())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Mcr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Mcr {{ maxmb: {=u8:?}, idam: {:?}, fden: {:?}, aen: {:?}, lprioen: {:?}, pnet_en: {=bool:?}, dma: {:?}, irmq: {:?}, srxdis: {:?}, waksrc: {=bool:?}, lpmack: {:?}, wrnen: {:?}, slfwak: {:?}, frzack: {:?}, softrst: {:?}, wakmsk: {:?}, notrdy: {:?}, halt: {:?}, rfen: {:?}, frz: {:?}, mdis: {:?} }}",
            self.maxmb(),
            self.idam(),
            self.fden(),
            self.aen(),
            self.lprioen(),
            self.pnet_en(),
            self.dma(),
            self.irmq(),
            self.srxdis(),
            self.waksrc(),
            self.lpmack(),
            self.wrnen(),
            self.slfwak(),
            self.frzack(),
            self.softrst(),
            self.wakmsk(),
            self.notrdy(),
            self.halt(),
            self.rfen(),
            self.frz(),
            self.mdis()
        )
    }
}
#[doc = "Pretended Networking Payload High Filter 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pl1Hi(pub u32);
impl Pl1Hi {
    #[doc = "Data byte 7"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 7"]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 6"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 6"]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 5"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 5"]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 4"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 4"]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Pl1Hi {
    #[inline(always)]
    fn default() -> Pl1Hi {
        Pl1Hi(0)
    }
}
impl core::fmt::Debug for Pl1Hi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pl1Hi")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pl1Hi {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pl1Hi {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Pretended Networking Payload Low Filter 1"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pl1Lo(pub u32);
impl Pl1Lo {
    #[doc = "Data byte 3"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3"]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 2"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2"]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 1"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1"]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 0"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0"]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Pl1Lo {
    #[inline(always)]
    fn default() -> Pl1Lo {
        Pl1Lo(0)
    }
}
impl core::fmt::Debug for Pl1Lo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pl1Lo")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pl1Lo {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pl1Lo {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Pretended Networking Payload High Filter 2 and Payload High Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pl2PlmaskHi(pub u32);
impl Pl2PlmaskHi {
    #[doc = "Data Byte 7"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 7"]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data Byte 6"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 6"]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data Byte 5"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 5"]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data Byte 4"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 4"]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Pl2PlmaskHi {
    #[inline(always)]
    fn default() -> Pl2PlmaskHi {
        Pl2PlmaskHi(0)
    }
}
impl core::fmt::Debug for Pl2PlmaskHi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pl2PlmaskHi")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pl2PlmaskHi {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pl2PlmaskHi {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Pretended Networking Payload Low Filter 2 and Payload Low Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Pl2PlmaskLo(pub u32);
impl Pl2PlmaskLo {
    #[doc = "Data Byte 3"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 3"]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data Byte 2"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 2"]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data Byte 1"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 1"]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data Byte 0"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 0"]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Pl2PlmaskLo {
    #[inline(always)]
    fn default() -> Pl2PlmaskLo {
        Pl2PlmaskLo(0)
    }
}
impl core::fmt::Debug for Pl2PlmaskLo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pl2PlmaskLo")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Pl2PlmaskLo {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Pl2PlmaskLo {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Receive 14 Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx14mask(pub u32);
impl Rx14mask {
    #[doc = "RX Buffer 14 Mask Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn rx14m(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "RX Buffer 14 Mask Bits"]
    #[inline(always)]
    pub const fn set_rx14m(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Rx14mask {
    #[inline(always)]
    fn default() -> Rx14mask {
        Rx14mask(0)
    }
}
impl core::fmt::Debug for Rx14mask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rx14mask")
            .field("rx14m", &self.rx14m())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rx14mask {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rx14mask {{ rx14m: {=u32:?} }}", self.rx14m())
    }
}
#[doc = "Receive 15 Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx15mask(pub u32);
impl Rx15mask {
    #[doc = "RX Buffer 15 Mask Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn rx15m(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "RX Buffer 15 Mask Bits"]
    #[inline(always)]
    pub const fn set_rx15m(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Rx15mask {
    #[inline(always)]
    fn default() -> Rx15mask {
        Rx15mask(0)
    }
}
impl core::fmt::Debug for Rx15mask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rx15mask")
            .field("rx15m", &self.rx15m())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rx15mask {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rx15mask {{ rx15m: {=u32:?} }}", self.rx15m())
    }
}
#[doc = "Legacy RX FIFO Global Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxfgmask(pub u32);
impl Rxfgmask {
    #[doc = "Legacy RX FIFO Global Mask Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn fgm(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "Legacy RX FIFO Global Mask Bits"]
    #[inline(always)]
    pub const fn set_fgm(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Rxfgmask {
    #[inline(always)]
    fn default() -> Rxfgmask {
        Rxfgmask(0)
    }
}
impl core::fmt::Debug for Rxfgmask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rxfgmask")
            .field("fgm", &self.fgm())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rxfgmask {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rxfgmask {{ fgm: {=u32:?} }}", self.fgm())
    }
}
#[doc = "Legacy RX FIFO Information"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxfir(pub u32);
impl Rxfir {
    #[doc = "Identifier Acceptance Filter Hit Indicator"]
    #[must_use]
    #[inline(always)]
    pub const fn idhit(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Identifier Acceptance Filter Hit Indicator"]
    #[inline(always)]
    pub const fn set_idhit(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
}
impl Default for Rxfir {
    #[inline(always)]
    fn default() -> Rxfir {
        Rxfir(0)
    }
}
impl core::fmt::Debug for Rxfir {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rxfir")
            .field("idhit", &self.idhit())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rxfir {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rxfir {{ idhit: {=u16:?} }}", self.idhit())
    }
}
#[doc = "Receive Individual Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rximr(pub u32);
impl Rximr {
    #[doc = "Individual Mask Bits"]
    #[must_use]
    #[inline(always)]
    pub const fn mi(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "Individual Mask Bits"]
    #[inline(always)]
    pub const fn set_mi(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Rximr {
    #[inline(always)]
    fn default() -> Rximr {
        Rximr(0)
    }
}
impl core::fmt::Debug for Rximr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rximr").field("mi", &self.mi()).finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rximr {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rximr {{ mi: {=u32:?} }}", self.mi())
    }
}
#[doc = "RX Message Buffers Global Mask"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxmgmask(pub u32);
impl Rxmgmask {
    #[doc = "Global Mask for RX Message Buffers"]
    #[must_use]
    #[inline(always)]
    pub const fn mg(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "Global Mask for RX Message Buffers"]
    #[inline(always)]
    pub const fn set_mg(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Rxmgmask {
    #[inline(always)]
    fn default() -> Rxmgmask {
        Rxmgmask(0)
    }
}
impl core::fmt::Debug for Rxmgmask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rxmgmask").field("mg", &self.mg()).finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Rxmgmask {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Rxmgmask {{ mg: {=u32:?} }}", self.mg())
    }
}
#[doc = "Free-Running Timer"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Timer(pub u32);
impl Timer {
    #[doc = "Timer Value"]
    #[must_use]
    #[inline(always)]
    pub const fn timer(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Timer Value"]
    #[inline(always)]
    pub const fn set_timer(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
}
impl Default for Timer {
    #[inline(always)]
    fn default() -> Timer {
        Timer(0)
    }
}
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer")
            .field("timer", &self.timer())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Timer {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "Timer {{ timer: {=u16:?} }}", self.timer())
    }
}
#[doc = "Wake-Up Message Buffer"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct WmbCs(pub u32);
impl WmbCs {
    #[doc = "Length of Data in Bytes"]
    #[must_use]
    #[inline(always)]
    pub const fn dlc(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0x0f;
        val as u8
    }
    #[doc = "Length of Data in Bytes"]
    #[inline(always)]
    pub const fn set_dlc(&mut self, val: u8) {
        self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
    }
    #[doc = "Remote Transmission Request"]
    #[must_use]
    #[inline(always)]
    pub const fn rtr(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "Remote Transmission Request"]
    #[inline(always)]
    pub const fn set_rtr(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "ID Extended Bit"]
    #[must_use]
    #[inline(always)]
    pub const fn ide(&self) -> super::vals::Ide {
        let val = (self.0 >> 21usize) & 0x01;
        super::vals::Ide::from_bits(val as u8)
    }
    #[doc = "ID Extended Bit"]
    #[inline(always)]
    pub const fn set_ide(&mut self, val: super::vals::Ide) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
    }
    #[doc = "Substitute Remote Request"]
    #[must_use]
    #[inline(always)]
    pub const fn srr(&self) -> super::vals::Srr {
        let val = (self.0 >> 22usize) & 0x01;
        super::vals::Srr::from_bits(val as u8)
    }
    #[doc = "Substitute Remote Request"]
    #[inline(always)]
    pub const fn set_srr(&mut self, val: super::vals::Srr) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
    }
}
impl Default for WmbCs {
    #[inline(always)]
    fn default() -> WmbCs {
        WmbCs(0)
    }
}
impl core::fmt::Debug for WmbCs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WmbCs")
            .field("dlc", &self.dlc())
            .field("rtr", &self.rtr())
            .field("ide", &self.ide())
            .field("srr", &self.srr())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for WmbCs {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "WmbCs {{ dlc: {=u8:?}, rtr: {=bool:?}, ide: {:?}, srr: {:?} }}",
            self.dlc(),
            self.rtr(),
            self.ide(),
            self.srr()
        )
    }
}
#[doc = "Wake-Up Message Buffer for Data 0-3"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct WmbD03(pub u32);
impl WmbD03 {
    #[doc = "Data Byte 3"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 3"]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data Byte 2"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 2"]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data Byte 1"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 1"]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data Byte 0"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 0"]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for WmbD03 {
    #[inline(always)]
    fn default() -> WmbD03 {
        WmbD03(0)
    }
}
impl core::fmt::Debug for WmbD03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WmbD03")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for WmbD03 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "WmbD03 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Wake-Up Message Buffer Register Data 4-7"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct WmbD47(pub u32);
impl WmbD47 {
    #[doc = "Data Byte 7"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 7"]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data Byte 6"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 6"]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data Byte 5"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 5"]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data Byte 4"]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data Byte 4"]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for WmbD47 {
    #[inline(always)]
    fn default() -> WmbD47 {
        WmbD47(0)
    }
}
impl core::fmt::Debug for WmbD47 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WmbD47")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for WmbD47 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "WmbD47 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Wake-Up Message Buffer for ID"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct WmbId(pub u32);
impl WmbId {
    #[doc = "Received ID in Pretended Networking Mode"]
    #[must_use]
    #[inline(always)]
    pub const fn id(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0x1fff_ffff;
        val as u32
    }
    #[doc = "Received ID in Pretended Networking Mode"]
    #[inline(always)]
    pub const fn set_id(&mut self, val: u32) {
        self.0 = (self.0 & !(0x1fff_ffff << 0usize)) | (((val as u32) & 0x1fff_ffff) << 0usize);
    }
}
impl Default for WmbId {
    #[inline(always)]
    fn default() -> WmbId {
        WmbId(0)
    }
}
impl core::fmt::Debug for WmbId {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WmbId").field("id", &self.id()).finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for WmbId {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "WmbId {{ id: {=u32:?} }}", self.id())
    }
}
#[doc = "Message Buffer 0 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word00(pub u32);
impl Word00 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word00 {
    #[inline(always)]
    fn default() -> Word00 {
        Word00(0)
    }
}
impl core::fmt::Debug for Word00 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word00")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word00 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word00 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 1 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word01(pub u32);
impl Word01 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word01 {
    #[inline(always)]
    fn default() -> Word01 {
        Word01(0)
    }
}
impl core::fmt::Debug for Word01 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word01")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word01 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word01 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 10 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word010(pub u32);
impl Word010 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word010 {
    #[inline(always)]
    fn default() -> Word010 {
        Word010(0)
    }
}
impl core::fmt::Debug for Word010 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word010")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word010 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word010 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 11 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word011(pub u32);
impl Word011 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word011 {
    #[inline(always)]
    fn default() -> Word011 {
        Word011(0)
    }
}
impl core::fmt::Debug for Word011 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word011")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word011 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word011 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 12 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word012(pub u32);
impl Word012 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word012 {
    #[inline(always)]
    fn default() -> Word012 {
        Word012(0)
    }
}
impl core::fmt::Debug for Word012 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word012")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word012 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word012 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 13 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word013(pub u32);
impl Word013 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word013 {
    #[inline(always)]
    fn default() -> Word013 {
        Word013(0)
    }
}
impl core::fmt::Debug for Word013 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word013")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word013 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word013 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 14 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word014(pub u32);
impl Word014 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word014 {
    #[inline(always)]
    fn default() -> Word014 {
        Word014(0)
    }
}
impl core::fmt::Debug for Word014 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word014")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word014 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word014 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 15 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word015(pub u32);
impl Word015 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word015 {
    #[inline(always)]
    fn default() -> Word015 {
        Word015(0)
    }
}
impl core::fmt::Debug for Word015 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word015")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word015 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word015 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 16 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word016(pub u32);
impl Word016 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word016 {
    #[inline(always)]
    fn default() -> Word016 {
        Word016(0)
    }
}
impl core::fmt::Debug for Word016 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word016")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word016 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word016 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 17 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word017(pub u32);
impl Word017 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word017 {
    #[inline(always)]
    fn default() -> Word017 {
        Word017(0)
    }
}
impl core::fmt::Debug for Word017 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word017")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word017 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word017 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 18 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word018(pub u32);
impl Word018 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word018 {
    #[inline(always)]
    fn default() -> Word018 {
        Word018(0)
    }
}
impl core::fmt::Debug for Word018 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word018")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word018 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word018 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 19 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word019(pub u32);
impl Word019 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word019 {
    #[inline(always)]
    fn default() -> Word019 {
        Word019(0)
    }
}
impl core::fmt::Debug for Word019 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word019")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word019 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word019 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 2 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word02(pub u32);
impl Word02 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word02 {
    #[inline(always)]
    fn default() -> Word02 {
        Word02(0)
    }
}
impl core::fmt::Debug for Word02 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word02")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word02 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word02 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 20 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word020(pub u32);
impl Word020 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word020 {
    #[inline(always)]
    fn default() -> Word020 {
        Word020(0)
    }
}
impl core::fmt::Debug for Word020 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word020")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word020 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word020 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 21 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word021(pub u32);
impl Word021 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word021 {
    #[inline(always)]
    fn default() -> Word021 {
        Word021(0)
    }
}
impl core::fmt::Debug for Word021 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word021")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word021 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word021 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 22 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word022(pub u32);
impl Word022 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word022 {
    #[inline(always)]
    fn default() -> Word022 {
        Word022(0)
    }
}
impl core::fmt::Debug for Word022 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word022")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word022 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word022 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 23 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word023(pub u32);
impl Word023 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word023 {
    #[inline(always)]
    fn default() -> Word023 {
        Word023(0)
    }
}
impl core::fmt::Debug for Word023 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word023")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word023 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word023 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 24 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word024(pub u32);
impl Word024 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word024 {
    #[inline(always)]
    fn default() -> Word024 {
        Word024(0)
    }
}
impl core::fmt::Debug for Word024 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word024")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word024 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word024 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 25 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word025(pub u32);
impl Word025 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word025 {
    #[inline(always)]
    fn default() -> Word025 {
        Word025(0)
    }
}
impl core::fmt::Debug for Word025 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word025")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word025 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word025 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 26 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word026(pub u32);
impl Word026 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word026 {
    #[inline(always)]
    fn default() -> Word026 {
        Word026(0)
    }
}
impl core::fmt::Debug for Word026 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word026")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word026 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word026 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 27 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word027(pub u32);
impl Word027 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word027 {
    #[inline(always)]
    fn default() -> Word027 {
        Word027(0)
    }
}
impl core::fmt::Debug for Word027 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word027")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word027 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word027 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 28 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word028(pub u32);
impl Word028 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word028 {
    #[inline(always)]
    fn default() -> Word028 {
        Word028(0)
    }
}
impl core::fmt::Debug for Word028 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word028")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word028 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word028 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 29 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word029(pub u32);
impl Word029 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word029 {
    #[inline(always)]
    fn default() -> Word029 {
        Word029(0)
    }
}
impl core::fmt::Debug for Word029 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word029")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word029 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word029 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 3 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word03(pub u32);
impl Word03 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word03 {
    #[inline(always)]
    fn default() -> Word03 {
        Word03(0)
    }
}
impl core::fmt::Debug for Word03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word03")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word03 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word03 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 30 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word030(pub u32);
impl Word030 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word030 {
    #[inline(always)]
    fn default() -> Word030 {
        Word030(0)
    }
}
impl core::fmt::Debug for Word030 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word030")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word030 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word030 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 31 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word031(pub u32);
impl Word031 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word031 {
    #[inline(always)]
    fn default() -> Word031 {
        Word031(0)
    }
}
impl core::fmt::Debug for Word031 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word031")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word031 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word031 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 4 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word04(pub u32);
impl Word04 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word04 {
    #[inline(always)]
    fn default() -> Word04 {
        Word04(0)
    }
}
impl core::fmt::Debug for Word04 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word04")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word04 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word04 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 5 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word05(pub u32);
impl Word05 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word05 {
    #[inline(always)]
    fn default() -> Word05 {
        Word05(0)
    }
}
impl core::fmt::Debug for Word05 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word05")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word05 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word05 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 6 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word06(pub u32);
impl Word06 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word06 {
    #[inline(always)]
    fn default() -> Word06 {
        Word06(0)
    }
}
impl core::fmt::Debug for Word06 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word06")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word06 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word06 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 7 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word07(pub u32);
impl Word07 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word07 {
    #[inline(always)]
    fn default() -> Word07 {
        Word07(0)
    }
}
impl core::fmt::Debug for Word07 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word07")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word07 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word07 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 8 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word08(pub u32);
impl Word08 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word08 {
    #[inline(always)]
    fn default() -> Word08 {
        Word08(0)
    }
}
impl core::fmt::Debug for Word08 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word08")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word08 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word08 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 9 WORD0 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word09(pub u32);
impl Word09 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_3(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_3(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_2(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_2(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_1(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_1(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_0(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_0(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word09 {
    #[inline(always)]
    fn default() -> Word09 {
        Word09(0)
    }
}
impl core::fmt::Debug for Word09 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word09")
            .field("data_byte_3", &self.data_byte_3())
            .field("data_byte_2", &self.data_byte_2())
            .field("data_byte_1", &self.data_byte_1())
            .field("data_byte_0", &self.data_byte_0())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word09 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word09 {{ data_byte_3: {=u8:?}, data_byte_2: {=u8:?}, data_byte_1: {=u8:?}, data_byte_0: {=u8:?} }}",
            self.data_byte_3(),
            self.data_byte_2(),
            self.data_byte_1(),
            self.data_byte_0()
        )
    }
}
#[doc = "Message Buffer 0 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word10(pub u32);
impl Word10 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word10 {
    #[inline(always)]
    fn default() -> Word10 {
        Word10(0)
    }
}
impl core::fmt::Debug for Word10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word10")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word10 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word10 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 1 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word11(pub u32);
impl Word11 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word11 {
    #[inline(always)]
    fn default() -> Word11 {
        Word11(0)
    }
}
impl core::fmt::Debug for Word11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word11")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word11 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word11 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 10 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word110(pub u32);
impl Word110 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word110 {
    #[inline(always)]
    fn default() -> Word110 {
        Word110(0)
    }
}
impl core::fmt::Debug for Word110 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word110")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word110 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word110 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 11 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word111(pub u32);
impl Word111 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word111 {
    #[inline(always)]
    fn default() -> Word111 {
        Word111(0)
    }
}
impl core::fmt::Debug for Word111 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word111")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word111 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word111 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 12 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word112(pub u32);
impl Word112 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word112 {
    #[inline(always)]
    fn default() -> Word112 {
        Word112(0)
    }
}
impl core::fmt::Debug for Word112 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word112")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word112 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word112 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 13 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word113(pub u32);
impl Word113 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word113 {
    #[inline(always)]
    fn default() -> Word113 {
        Word113(0)
    }
}
impl core::fmt::Debug for Word113 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word113")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word113 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word113 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 14 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word114(pub u32);
impl Word114 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word114 {
    #[inline(always)]
    fn default() -> Word114 {
        Word114(0)
    }
}
impl core::fmt::Debug for Word114 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word114")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word114 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word114 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 15 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word115(pub u32);
impl Word115 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word115 {
    #[inline(always)]
    fn default() -> Word115 {
        Word115(0)
    }
}
impl core::fmt::Debug for Word115 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word115")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word115 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word115 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 16 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word116(pub u32);
impl Word116 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word116 {
    #[inline(always)]
    fn default() -> Word116 {
        Word116(0)
    }
}
impl core::fmt::Debug for Word116 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word116")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word116 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word116 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 17 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word117(pub u32);
impl Word117 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word117 {
    #[inline(always)]
    fn default() -> Word117 {
        Word117(0)
    }
}
impl core::fmt::Debug for Word117 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word117")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word117 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word117 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 18 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word118(pub u32);
impl Word118 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word118 {
    #[inline(always)]
    fn default() -> Word118 {
        Word118(0)
    }
}
impl core::fmt::Debug for Word118 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word118")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word118 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word118 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 19 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word119(pub u32);
impl Word119 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word119 {
    #[inline(always)]
    fn default() -> Word119 {
        Word119(0)
    }
}
impl core::fmt::Debug for Word119 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word119")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word119 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word119 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 2 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word12(pub u32);
impl Word12 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word12 {
    #[inline(always)]
    fn default() -> Word12 {
        Word12(0)
    }
}
impl core::fmt::Debug for Word12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word12")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word12 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word12 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 20 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word120(pub u32);
impl Word120 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word120 {
    #[inline(always)]
    fn default() -> Word120 {
        Word120(0)
    }
}
impl core::fmt::Debug for Word120 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word120")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word120 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word120 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 21 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word121(pub u32);
impl Word121 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word121 {
    #[inline(always)]
    fn default() -> Word121 {
        Word121(0)
    }
}
impl core::fmt::Debug for Word121 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word121")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word121 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word121 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 22 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word122(pub u32);
impl Word122 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word122 {
    #[inline(always)]
    fn default() -> Word122 {
        Word122(0)
    }
}
impl core::fmt::Debug for Word122 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word122")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word122 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word122 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 23 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word123(pub u32);
impl Word123 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word123 {
    #[inline(always)]
    fn default() -> Word123 {
        Word123(0)
    }
}
impl core::fmt::Debug for Word123 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word123")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word123 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word123 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 24 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word124(pub u32);
impl Word124 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word124 {
    #[inline(always)]
    fn default() -> Word124 {
        Word124(0)
    }
}
impl core::fmt::Debug for Word124 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word124")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word124 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word124 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 25 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word125(pub u32);
impl Word125 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word125 {
    #[inline(always)]
    fn default() -> Word125 {
        Word125(0)
    }
}
impl core::fmt::Debug for Word125 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word125")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word125 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word125 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 26 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word126(pub u32);
impl Word126 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word126 {
    #[inline(always)]
    fn default() -> Word126 {
        Word126(0)
    }
}
impl core::fmt::Debug for Word126 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word126")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word126 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word126 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 27 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word127(pub u32);
impl Word127 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word127 {
    #[inline(always)]
    fn default() -> Word127 {
        Word127(0)
    }
}
impl core::fmt::Debug for Word127 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word127")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word127 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word127 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 28 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word128(pub u32);
impl Word128 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word128 {
    #[inline(always)]
    fn default() -> Word128 {
        Word128(0)
    }
}
impl core::fmt::Debug for Word128 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word128")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word128 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word128 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 29 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word129(pub u32);
impl Word129 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word129 {
    #[inline(always)]
    fn default() -> Word129 {
        Word129(0)
    }
}
impl core::fmt::Debug for Word129 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word129")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word129 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word129 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 3 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word13(pub u32);
impl Word13 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word13 {
    #[inline(always)]
    fn default() -> Word13 {
        Word13(0)
    }
}
impl core::fmt::Debug for Word13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word13")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word13 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word13 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 30 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word130(pub u32);
impl Word130 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word130 {
    #[inline(always)]
    fn default() -> Word130 {
        Word130(0)
    }
}
impl core::fmt::Debug for Word130 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word130")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word130 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word130 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 31 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word131(pub u32);
impl Word131 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word131 {
    #[inline(always)]
    fn default() -> Word131 {
        Word131(0)
    }
}
impl core::fmt::Debug for Word131 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word131")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word131 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word131 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 4 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word14(pub u32);
impl Word14 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word14 {
    #[inline(always)]
    fn default() -> Word14 {
        Word14(0)
    }
}
impl core::fmt::Debug for Word14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word14")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word14 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word14 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 5 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word15(pub u32);
impl Word15 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word15 {
    #[inline(always)]
    fn default() -> Word15 {
        Word15(0)
    }
}
impl core::fmt::Debug for Word15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word15")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word15 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word15 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 6 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word16(pub u32);
impl Word16 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word16 {
    #[inline(always)]
    fn default() -> Word16 {
        Word16(0)
    }
}
impl core::fmt::Debug for Word16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word16")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word16 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word16 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 7 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word17(pub u32);
impl Word17 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word17 {
    #[inline(always)]
    fn default() -> Word17 {
        Word17(0)
    }
}
impl core::fmt::Debug for Word17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word17")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word17 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word17 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 8 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word18(pub u32);
impl Word18 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word18 {
    #[inline(always)]
    fn default() -> Word18 {
        Word18(0)
    }
}
impl core::fmt::Debug for Word18 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word18")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word18 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word18 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Message Buffer 9 WORD1 Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Word19(pub u32);
impl Word19 {
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_7(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 0 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_7(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_6(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 1 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_6(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_5(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 2 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_5(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[must_use]
    #[inline(always)]
    pub const fn data_byte_4(&self) -> u8 {
        let val = (self.0 >> 24usize) & 0xff;
        val as u8
    }
    #[doc = "Data byte 3 of Rx/Tx frame."]
    #[inline(always)]
    pub const fn set_data_byte_4(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
    }
}
impl Default for Word19 {
    #[inline(always)]
    fn default() -> Word19 {
        Word19(0)
    }
}
impl core::fmt::Debug for Word19 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Word19")
            .field("data_byte_7", &self.data_byte_7())
            .field("data_byte_6", &self.data_byte_6())
            .field("data_byte_5", &self.data_byte_5())
            .field("data_byte_4", &self.data_byte_4())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Word19 {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Word19 {{ data_byte_7: {=u8:?}, data_byte_6: {=u8:?}, data_byte_5: {=u8:?}, data_byte_4: {=u8:?} }}",
            self.data_byte_7(),
            self.data_byte_6(),
            self.data_byte_5(),
            self.data_byte_4()
        )
    }
}
#[doc = "Pretended Networking Wake-Up Match"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct WuMtc(pub u32);
impl WuMtc {
    #[doc = "Number of Matches in Pretended Networking"]
    #[must_use]
    #[inline(always)]
    pub const fn mcounter(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0xff;
        val as u8
    }
    #[doc = "Number of Matches in Pretended Networking"]
    #[inline(always)]
    pub const fn set_mcounter(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
    }
    #[doc = "Wake-up by Match Flag"]
    #[must_use]
    #[inline(always)]
    pub const fn wumf(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-up by Match Flag"]
    #[inline(always)]
    pub const fn set_wumf(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "Wake-up by Timeout Flag Bit"]
    #[must_use]
    #[inline(always)]
    pub const fn wtof(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "Wake-up by Timeout Flag Bit"]
    #[inline(always)]
    pub const fn set_wtof(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
}
impl Default for WuMtc {
    #[inline(always)]
    fn default() -> WuMtc {
        WuMtc(0)
    }
}
impl core::fmt::Debug for WuMtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WuMtc")
            .field("mcounter", &self.mcounter())
            .field("wumf", &self.wumf())
            .field("wtof", &self.wtof())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for WuMtc {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "WuMtc {{ mcounter: {=u8:?}, wumf: {=bool:?}, wtof: {=bool:?} }}",
            self.mcounter(),
            self.wumf(),
            self.wtof()
        )
    }
}
